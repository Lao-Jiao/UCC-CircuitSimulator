document.addEventListener('DOMContentLoaded', () => {
    const gridContainer = document.getElementById('grid-container');
    const gridBg = document.querySelector('.grid-bg');
    const addNodeBtn = document.getElementById('add-node');
    const addBranchBtn = document.getElementById('add-branch');
    const clearBtn = document.getElementById('clear');
    const nodeColorInput = document.getElementById('node-color');
    const sidebarIcons = document.querySelectorAll('.sidebar-icon');
    
    // 添加组件计数器，用于生成唯一ID
    const componentCounters = {
        '开关触发器': 0,
        '灯': 0,
        '延时触发器': 0,
        '与门（&）': 0,
        'XOR信号器': 0,
        '或门（OR）': 0,
        '非门（NOT）': 0,
        '分支（BR）': 0,
        '标记储存装置': 0
    };
    
    // 全局变量，用于跟踪选择模式和选中的节点
    let isSelectMode = false;
    // 添加全局变量用于跟踪所有选中的节点
    let selectedNodes = [];
    
    // 创建日志区域
    createLogPanel();
    
    // 创建日志面板函数
    function createLogPanel() {
        // 创建日志面板容器
        const logPanelContainer = document.createElement('div');
        logPanelContainer.id = 'log-panel-container';
        logPanelContainer.style.position = 'fixed';
        logPanelContainer.style.right = '20px';
        logPanelContainer.style.top = '80px';
        logPanelContainer.style.width = '350px';
        logPanelContainer.style.height = 'calc(100vh - 100px)';
        logPanelContainer.style.backgroundColor = 'rgba(0, 0, 0, 0.8)';
        logPanelContainer.style.border = '1px solid #444';
        logPanelContainer.style.borderRadius = '8px';
        logPanelContainer.style.zIndex = '1000';
        logPanelContainer.style.display = 'flex';
        logPanelContainer.style.flexDirection = 'column';
        
        // 创建日志面板标题
        const logPanelHeader = document.createElement('div');
        logPanelHeader.id = 'log-panel-header';
        logPanelHeader.style.display = 'flex';
        logPanelHeader.style.justifyContent = 'space-between';
        logPanelHeader.style.alignItems = 'center';
        logPanelHeader.style.padding = '10px';
        logPanelHeader.style.borderBottom = '1px solid #444';
        logPanelHeader.style.color = '#fff';
        logPanelHeader.style.fontSize = '16px';
        logPanelHeader.style.fontWeight = 'bold';
        logPanelHeader.textContent = '电路日志';
        
        // 创建日志操作按钮容器
        const logPanelActions = document.createElement('div');
        
        // 创建清除日志按钮
        const clearLogBtn = document.createElement('button');
        clearLogBtn.textContent = '清除日志';
        clearLogBtn.style.padding = '5px 10px';
        clearLogBtn.style.backgroundColor = '#555';
        clearLogBtn.style.color = '#fff';
        clearLogBtn.style.border = 'none';
        clearLogBtn.style.borderRadius = '4px';
        clearLogBtn.style.cursor = 'pointer';
        clearLogBtn.onclick = function() {
            const logPanel = document.getElementById('log-panel-content');
            if (logPanel) {
                logPanel.innerHTML = '';
            }
        };
        
        // 创建显示/隐藏按钮
        const toggleLogBtn = document.createElement('button');
        toggleLogBtn.textContent = '隐藏';
        toggleLogBtn.style.padding = '5px 10px';
        toggleLogBtn.style.backgroundColor = '#555';
        toggleLogBtn.style.color = '#fff';
        toggleLogBtn.style.border = 'none';
        toggleLogBtn.style.borderRadius = '4px';
        toggleLogBtn.style.marginLeft = '5px';
        toggleLogBtn.style.cursor = 'pointer';
        toggleLogBtn.onclick = function() {
            const logPanel = document.getElementById('log-panel-content');
            if (logPanel.style.display === 'none') {
                logPanel.style.display = 'block';
                toggleLogBtn.textContent = '隐藏';
                logPanelContainer.style.height = 'calc(100vh - 100px)';
            } else {
                logPanel.style.display = 'none';
                toggleLogBtn.textContent = '显示';
                logPanelContainer.style.height = 'auto';
            }
        };
        
        // 将按钮添加到操作容器
        logPanelActions.appendChild(clearLogBtn);
        logPanelActions.appendChild(toggleLogBtn);
        
        // 将标题和操作添加到标题栏
        logPanelHeader.appendChild(logPanelActions);
        
        // 创建日志内容区域
        const logPanelContent = document.createElement('div');
        logPanelContent.id = 'log-panel-content';
        logPanelContent.style.flex = '1';
        logPanelContent.style.padding = '10px';
        logPanelContent.style.overflowY = 'auto';
        logPanelContent.style.color = '#ddd';
        logPanelContent.style.fontSize = '14px';
        logPanelContent.style.fontFamily = 'monospace';
        
        // 组合面板
        logPanelContainer.appendChild(logPanelHeader);
        logPanelContainer.appendChild(logPanelContent);
        
        // 添加到文档
        document.body.appendChild(logPanelContainer);
        
        // 替换console.log函数，同时输出到控制台和日志面板
        const originalConsoleLog = console.log;
        console.log = function() {
            // 调用原始的console.log
            originalConsoleLog.apply(console, arguments);
            
            // 将日志添加到面板
            const logPanel = document.getElementById('log-panel-content');
            if (logPanel) {
                // 创建一个新的日志条目
                const logEntry = document.createElement('div');
                logEntry.style.marginBottom = '5px';
                logEntry.style.borderBottom = '1px solid #333';
                logEntry.style.paddingBottom = '5px';
                
                // 获取当前时间
                const now = new Date();
                const timeStr = now.getHours().toString().padStart(2, '0') + ':' +
                                now.getMinutes().toString().padStart(2, '0') + ':' +
                                now.getSeconds().toString().padStart(2, '0') + '.' +
                                now.getMilliseconds().toString().padStart(3, '0');
                
                // 添加时间戳
                const timestamp = document.createElement('span');
                timestamp.style.color = '#888';
                timestamp.style.marginRight = '5px';
                timestamp.textContent = `[${timeStr}]`;
                logEntry.appendChild(timestamp);
                
                // 添加日志内容
                const content = document.createElement('span');
                // 将参数合并成一个字符串
                const message = Array.from(arguments).map(arg => {
                    return (typeof arg === 'object') ? JSON.stringify(arg) : String(arg);
                }).join(' ');
                
                // 根据日志内容添加颜色
                if (message.includes('错误') || message.includes('失败') || message.includes('取消')) {
                    content.style.color = '#ff6b6b'; // 红色
                } else if (message.includes('成功') || message.includes('传递信号 1')) {
                    content.style.color = '#69db7c'; // 绿色
                } else if (message.includes('连接') || message.includes('标记储存装置')) {
                    content.style.color = '#4dabf7'; // 蓝色
                } else if (message.includes('开关触发器')) {
                    content.style.color = '#ffd43b'; // 黄色
                } else if (message.includes('与门')) {
                    content.style.color = '#ae3ec9'; // 紫色
                }
                
                content.textContent = message;
                logEntry.appendChild(content);
                
                // 添加到日志面板
                logPanel.appendChild(logEntry);
                
                // 滚动到底部
                logPanel.scrollTop = logPanel.scrollHeight;
            }
        };
    }
    
    // 添加调试信息记录函数
    function logCircuitState() {
        console.log('========= 电路状态信息 =========');
        
        // 记录节点信息
        nodes.forEach((node, index) => {
            if (!node.dataset.componentType) return;
            
            const type = node.dataset.componentType;
            const id = node.dataset.componentId || '';
            const inputs = node.state ? node.state.inputValues : [];
            const outputs = node.state ? node.state.outputValues : [];
            const isActive = node.classList.contains('active');
            
            console.log(`节点${index} [${type}${id}]: 激活=${isActive}, 输入=[${inputs.join(',')}], 输出=[${outputs.join(',')}]`);
        });
        
        // 记录连接信息
        connections.forEach((conn, index) => {
            if (!conn.startNode || !conn.endNode) return;
            
            const startType = conn.startNode.dataset.componentType || '未知';
            const endType = conn.endNode.dataset.componentType || '未知';
            const startId = conn.startNode.dataset.componentId || '';
            const endId = conn.endNode.dataset.componentId || '';
            const inputIndex = conn.inputIndex;
            
            console.log(`连接${index}: [${startType}${startId}] -> [${endType}${endId}], 输入端口=${inputIndex}`);
        });
        
        console.log('========= 电路状态结束 =========');
    }
    
    // 在关键节点处调用状态记录

    let nodes = [];
    let branches = [];
    let isDragging = false;
    let isPanning = false;
    let currentNode = null;
    let nodeMode = false;
    let branchMode = false;
    let branchStart = null;
    let branchStartPort = null;  // 连线起始端口
    let currentColor = nodeColorInput.value;
    let panStart = { x: 0, y: 0 };
    let panOffset = { x: 0, y: 0 };
    // 将panOffset暴露为全局变量，供connection.js访问
    window.panOffset = panOffset;
    let lastPan = { x: 0, y: 0 };
    const gridSize = 48; // 与CSS变量保持一致
    let dragIconType = null;
    let dragIconSrc = null;
    let circuitRunning = false;  // 电路运行状态
    
    // 添加节点选择和删除功能
    let hoveredNode = null;  // 跟踪当前鼠标悬停的节点
    
    // 添加全局变量用于跟踪连接状态
    let connectingStart = null; // 连接起始节点
    let connections = []; // 存储连接线
    
    // 组件逻辑定义
    const componentLogic = {
        '开关触发器': {
            inputs: 1,  // 只允许1个输入
            outputs: 1, // 只允许1个输出
            process: function(inputs, node) {
                // 组件ID用于日志
                const nodeId = node ? node.dataset.componentId || '' : '';
                
                // 只判断有实际输入的端口（即非undefined）
                const validInputs = inputs.filter(v => v !== undefined);
                
                // 检查是否有输入信号且为0，如果是，则强制开关为关闭状态
                if (validInputs.length > 0 && validInputs[0] === 0) {
                    // 如果开关当前是打开状态，需要强制关闭它
                    if (node && node.classList.contains('active')) {
                        console.log(`开关触发器${nodeId}接收到输入信号0，强制关闭状态`);
                        // 异步更新UI状态，避免在处理过程中修改DOM
                        requestAnimationFrame(() => {
                            node.classList.remove('active');
                            node.state.outputValues[0] = 0;
                        });
                    }
                    return 0; // 输出0
                }
                
                // 正常处理逻辑
                // 如果开关处于关闭状态（非active），则始终输出0
                if (!node || !node.classList.contains('active')) {
                    console.log(`开关触发器${nodeId}处于关闭状态，输出: 0`);
                    return 0;
                }
                
                // 如果开关处于打开状态，且有有效输入，则传递输入信号
                if (validInputs.length > 0) {
                    const result = validInputs[0] ? 1 : 0;
                    console.log(`开关触发器${nodeId}处于打开状态，处理输入: [${validInputs.join(', ')}], 输出: ${result}`);
                    return result;
                }
                
                // 如果开关处于打开状态，但没有有效输入，则输出1
                console.log(`开关触发器${nodeId}处于打开状态，无输入，输出: 1`);
                return 1;
            }
        },
        '灯': {
            inputs: 1,
            outputs: 0, // 没有输出
            process: function(inputs, node) {
                // 组件ID用于日志
                const nodeId = node ? node.dataset.componentId || '' : '';
                
                // 只判断有实际输入的端口（即非undefined）
                const validInputs = inputs.filter(v => v !== undefined);
                
                // 如果没有有效输入，默认为熄灭状态
                const isOn = validInputs.length > 0 ? validInputs[0] : false;
                
                console.log(`灯${nodeId}处理输入: [${validInputs.join(', ')}], 状态: ${isOn ? '亮' : '灭'}`);
                
                // 更换图片
                if (node && node.querySelector('.node-icon-img')) {
                    const imgEl = node.querySelector('.node-icon-img');
                    
                    if (isOn) {
                        // 切换为亮灯图片
                        imgEl.src = 'PNG/灯亮起.png';
                        node.classList.add('active');
                    } else {
                        // 切换为普通灯图片
                        imgEl.src = 'PNG/灯.png';
                        node.classList.remove('active');
                    }
                }
                
                return 0; // 灯没有输出
            }
        },
        '延时触发器': {
            inputs: 1,
            outputs: 1,
            process: function(inputs, node) {
                // 只判断有实际输入的端口（即非undefined）
                const validInputs = inputs.filter(v => v !== undefined);
                
                // 如果没有有效输入，输出0
                if(validInputs.length === 0) return 0;
                
                if(validInputs[0]) {
                    // 记录当前时间，使用自定义延时后输出
                    if(!node.processingDelay) {
                        node.processingDelay = true;
                        
                        // 获取延时时间，默认为1秒
                        const delayTime = (node.delayTime || 1) * 1000; // 转换为毫秒
                        
                        console.log(`延时触发器收到信号1，将在${delayTime/1000}秒后输出`);
                        
                        setTimeout(() => {
                            // 延时结束后更新输出信号
                            node.state.outputValues[0] = 1;
                            node.classList.add('active');
                            console.log(`延时触发器延时(${delayTime/1000}秒)结束，输出信号1`);
                            
                            // 清除延时状态标记
                            node.processingDelay = false;
                            
                            // 更新信号指示器
                            if(node.signalIndicator) {
                                node.signalIndicator.textContent = "1";
                                node.signalIndicator.style.backgroundColor = 'rgba(0, 128, 0, 0.7)';
                                node.signalIndicator.style.boxShadow = '0 0 5px rgba(0, 255, 0, 0.5)';
                            }
                            
                            // 传播信号到后续节点
                            propagateSignal(node);
                        }, delayTime);
                    }
                    // 延时中返回0，等待延时结束后再输出1
                    return 0;
                }
                console.log(`延时触发器收到信号0，输出0`);
                
                // 如果延时器收到0信号，清除延时状态
                if(node.processingDelay) {
                    node.processingDelay = false;
                    console.log('延时触发器取消延时');
                }
                
                return 0;
            }
        },
        '与门（&）': {
            inputs: Infinity, // 无限输入
            outputs: 1,
            process: function(inputs, node) {
                // 组件ID用于日志
                const nodeId = node ? node.dataset.componentId || '' : '';
                
                // 打印原始输入数组，便于调试
                console.log(`与门${nodeId}处理: 原始输入数组: [${inputs.join(', ')}]`);
                
                // 重要修改：只考虑实际连接的输入（即非undefined且建立了连接的）
                // 查找与这个与门相关的所有输入连接
                const connectedInputs = connections.filter(conn => conn.endNode === node);
                console.log(`与门${nodeId}处理: 实际连接数量: ${connectedInputs.length}`);
                
                // 如果没有连接，则输出0
                if(connectedInputs.length === 0) {
                    console.log(`与门${nodeId}处理: 没有连接的输入，输出0`);
                    return 0;
                }
                
                // 检查所有连接的输入信号
                let allConnectedInputsAreOne = true;
                let connectedValues = [];
                
                // 遍历每个连接，获取其输入值
                connectedInputs.forEach(conn => {
                    const inputIndex = conn.inputIndex;
                    const inputValue = inputs[inputIndex];
                    connectedValues.push(inputValue);
                    
                    if(inputValue !== 1) {
                        allConnectedInputsAreOne = false;
                    }
                });
                
                // 输出取决于所有连接的输入是否都为1
                const result = allConnectedInputsAreOne ? 1 : 0;
                
                // 详细记录连接的输入值及最终判断结果
                console.log(`与门${nodeId}处理: 连接的输入值: [${connectedValues.join(', ')}]`);
                console.log(`与门${nodeId}处理: 所有连接的输入都是1? ${allConnectedInputsAreOne}, 最终输出: ${result}`);
                
                return result;
            }
        },
        'XOR信号器': {
            inputs: 2,
            outputs: 1,
            process: function(inputs, node) {
                // 组件ID用于日志
                const nodeId = node ? node.dataset.componentId || '' : '';
                
                // 查找连接到此XOR信号器的输入连接
                const connectedInputs = connections.filter(conn => conn.endNode === node);
                
                // 记录详细日志，帮助调试
                console.log(`XOR信号器${nodeId}连接情况: 共${connectedInputs.length}个输入连接`);
                
                // 直接从节点状态获取当前输入值
                console.log(`XOR信号器${nodeId}原始输入数组: [${inputs.join(', ')}]`);
                
                // 整理输入值，确保我们有数组中的有效值
                let validInputs = [0, 0]; // 默认两个输入为0
                
                // 根据连接状态确定输入值
                if (connectedInputs.length > 0) {
                    // 只处理已连接的端口
                    connectedInputs.forEach(conn => {
                        const inputIndex = conn.inputIndex;
                        // 检查输入值是否有定义，如果没有则默认为0
                        validInputs[inputIndex] = inputs[inputIndex] !== undefined ? inputs[inputIndex] : 0;
                        console.log(`XOR信号器${nodeId}端口${inputIndex}的输入值: ${validInputs[inputIndex]} (原始值: ${inputs[inputIndex]})`);
                    });
                    
                    // 确保我们有两个有效的输入连接
                    if (connectedInputs.length < 2) {
                        console.log(`XOR信号器${nodeId}输入连接不足，输出: 0`);
                        return 0;
                    }
                    
                    // 检查是否形成循环连接
                    const isCircular = checkCircularConnection(node);
                    if (isCircular) {
                        console.log(`XOR信号器${nodeId}检测到循环连接，使用当前输入值计算`);
                    }
                    
                    // 正确实现XOR逻辑：当两个输入不同时输出1，相同时输出0
                    const result = validInputs[0] !== validInputs[1] ? 1 : 0;
                    console.log(`XOR信号器${nodeId}处理输入: [${validInputs[0]}, ${validInputs[1]}], 输出: ${result}`);
                    return result;
                } else {
                    // 没有连接的情况
                    console.log(`XOR信号器${nodeId}没有输入连接，输出: 0`);
                    return 0;
                }
            }
        },
        '或门（OR）': {
            inputs: Infinity,
            outputs: 1,
            process: function(inputs) {
                // 只判断有实际输入的端口（即非undefined）
                const validInputs = inputs.filter(v => v !== undefined);
                
                // 如果没有有效输入，输出0
                if(validInputs.length === 0) return 0;
                
                // 至少一个输入为1就输出1
                const result = validInputs.some(val => val === 1) ? 1 : 0;
                console.log(`或门处理输入: [${validInputs.join(', ')}], 输出: ${result}`);
                return result;
            }
        },
        '非门（NOT）': {
            inputs: 1,
            outputs: 1,
            process: function(inputs, node) {
                // 组件ID用于日志
                const nodeId = node ? node.dataset.componentId || '' : '';
                
                // 只判断有实际输入的端口（即非undefined）
                const validInputs = inputs.filter(v => v !== undefined);
                
                // 如果没有有效输入，输出0（非门必须有输入才能输出）
                if(validInputs.length === 0) {
                    console.log(`非门${nodeId}没有有效输入，输出: 0`);
                    return 0;
                }
                
                // 输入为0输出1，输入为1输出0
                const result = validInputs[0] ? 0 : 1;
                console.log(`非门${nodeId}处理输入: [${validInputs.join(', ')}], 输出: ${result}`);
                return result;
            }
        },
        '分支（BR）': {
            inputs: 1,
            outputs: Infinity, // 可以有多个输出
            process: function(inputs) {
                // 只判断有实际输入的端口（即非undefined）
                const validInputs = inputs.filter(v => v !== undefined);
                
                // 如果没有有效输入，输出0
                if(validInputs.length === 0) return 0;
                
                // 分支节点只传递信号，不改变值
                const result = validInputs[0] ? 1 : 0;
                console.log(`分支处理输入: [${validInputs.join(', ')}], 输出: ${result}`);
                return result;
            }
        },
        '标记储存装置': {
            inputs: 2,  // 两个输入端
            outputs: 1,
            process: function(inputs, node) {
                // 只判断有实际输入的端口（即非undefined）
                const validInputs = inputs.filter(v => v !== undefined);
                
                // 如果没有有效输入，输出0
                if(validInputs.length === 0) {
                    console.log(`标记储存装置无输入，输出: 0`);
                    return 0;
                }
                
                // 初始化控制端和输入端的识别状态
                if (!node.state.controlPortIdentified) {
                    // 第一个非undefined的信号是控制端
                    for (let i = 0; i < inputs.length; i++) {
                        if (inputs[i] !== undefined) {
                            node.state.controlPort = i;
                            node.state.controlPortIdentified = true;
                            console.log(`标记储存装置：识别到控制端为端口 ${i}`);
                            break;
                        }
                    }
                }
                
                // 如果控制端已识别
                if (node.state.controlPortIdentified) {
                    const controlInput = inputs[node.state.controlPort];
                    
                    // 找到数据输入端（不是控制端的其他端口）
                    let dataInput = undefined;
                    for (let i = 0; i < inputs.length; i++) {
                        if (i !== node.state.controlPort && inputs[i] !== undefined) {
                            dataInput = inputs[i];
                            break;
                        }
                    }
                    
                    // 当控制端为0时，输出始终为0
                    if (controlInput === 0) {
                        console.log(`标记储存装置控制端为0，无论输入是什么，输出: 0`);
                        return 0;
                    }
                    
                    // 当控制端为1时，输出等于输入端的信号（如果有）
                    if (dataInput !== undefined) {
                        console.log(`标记储存装置控制端为1，输入端为: ${dataInput}，输出: ${dataInput}`);
                        return dataInput;
                    } else {
                        console.log(`标记储存装置控制端为1，但没有数据输入，输出: 0`);
                        return 0;
                    }
                }
                
                // 默认情况，只有一个输入时暂不能确定逻辑
                console.log(`标记储存装置暂不能确定逻辑，输出: 0`);
                return 0;
            },
            reset: function(node) {
                // 重置功能，包括清除控制端识别状态
                node.state.stored = false;
                node.state.controlPortIdentified = false;
                node.state.controlPort = undefined;
                console.log(`标记储存装置重置，控制端识别状态已清除`);
                return 0;
            }
        }
    };
    
    // 检查是否存在循环连接
    function checkCircularConnection(node, visited = new Set(), depth = 0) {
        if (depth > 10) return true; // 深度超过限制，认为存在循环
        if (visited.has(node)) return true; // 节点已访问过，存在循环
        
        // 将当前节点加入已访问集合
        visited.add(node);
        
        // 获取从此节点出发的所有连接
        const outgoingConnections = connections.filter(conn => conn.startNode === node);
        
        // 递归检查每个下游节点
        for (const conn of outgoingConnections) {
            const nextNode = conn.endNode;
            if (checkCircularConnection(nextNode, new Set([...visited]), depth + 1)) {
                return true;
            }
        }
        
        return false;
    }
    
    // 吸附点可视化辅助
    let snapPointEl = null;
    function showSnapPoint(x, y) {
        if (!snapPointEl) {
            snapPointEl = document.createElement('div');
            snapPointEl.style.position = 'absolute';
            snapPointEl.style.width = '8px';
            snapPointEl.style.height = '8px';
            snapPointEl.style.background = 'red';
            snapPointEl.style.borderRadius = '50%';
            snapPointEl.style.zIndex = 1000;
            snapPointEl.style.pointerEvents = 'none';
            gridContainer.appendChild(snapPointEl);
        }
        snapPointEl.style.left = `${x - 4 + panOffset.x}px`;
        snapPointEl.style.top = `${y - 4 + panOffset.y}px`;
        snapPointEl.style.display = 'block';
    }
    function hideSnapPoint() {
        if (snapPointEl) snapPointEl.style.display = 'none';
    }
    
    // 更新CSS变量
    function updateColorTheme(color) {
        document.documentElement.style.setProperty('--primary-color', color);
        currentColor = color;
    }
    
    // 创建新节点（可选带图标）
    function createNode(x, y, iconSrc = null, iconType = null) {
        const node = document.createElement('div');
        if (iconSrc) {
            node.className = 'node node-icon-card';
            node.dataset.componentType = iconType;
            
            // 分配组件ID
            if (componentCounters.hasOwnProperty(iconType)) {
                componentCounters[iconType]++;
                node.dataset.componentId = componentCounters[iconType];
            }

            // 初始化多输入/多输出的状态
            node.state = {
                inputValues: [],
                outputValues: [],
                stored: false
            };
            // 根据组件类型初始化输入/输出数组长度
            if(componentLogic[iconType]) {
                const logic = componentLogic[iconType];
                
                // 为开关触发器特殊处理，初始化inputValues为undefined
                if (iconType === '开关触发器') {
                    node.state.inputValues = new Array(logic.inputs === Infinity ? 2 : logic.inputs).fill(undefined);
                    node.state.outputValues = new Array(logic.outputs === Infinity ? 2 : logic.outputs).fill(0);
                    node.state.outputValues[0] = 0;
                    node.classList.remove('active');
                    console.log(`创建开关触发器${node.dataset.componentId}，初始状态为关闭，输出: 0，输入未连接`);
                } else {
                    // 其他组件保持原有初始化方式
                node.state.inputValues = new Array(logic.inputs === Infinity ? 2 : logic.inputs).fill(0);
                node.state.outputValues = new Array(logic.outputs === Infinity ? 2 : logic.outputs).fill(0);
            }
                
                // 为标记储存装置添加控制端识别状态
                if (iconType === '标记储存装置') {
                    node.state.controlPortIdentified = false; // 控制端是否已识别
                    node.state.controlPort = undefined;       // 控制端索引
                    console.log(`创建标记储存装置${node.dataset.componentId}，控制端尚未识别`);
                }
                
                // 为节点添加信号状态指示器（如果有输出）
                if (logic.outputs > 0) {
                    const signalIndicator = document.createElement('div');
                    signalIndicator.className = 'signal-indicator';
                    signalIndicator.textContent = '0'; // 默认显示0
                    
                    // 根据组件类型设置样式
                    signalIndicator.style.position = 'absolute';
                    signalIndicator.style.top = '-18px'; // 定位在组件上方
                    signalIndicator.style.left = '50%';
                    signalIndicator.style.transform = 'translateX(-50%)';
                    signalIndicator.style.backgroundColor = 'rgba(0, 0, 0, 0.6)';
                    signalIndicator.style.color = 'white';
                    signalIndicator.style.padding = '2px 8px';
                    signalIndicator.style.borderRadius = '10px';
                    signalIndicator.style.fontSize = '12px';
                    signalIndicator.style.fontWeight = 'bold';
                    signalIndicator.style.zIndex = '5';
                    signalIndicator.style.userSelect = 'none';
                    signalIndicator.style.pointerEvents = 'none'; // 防止干扰点击事件
                    
                    node.appendChild(signalIndicator);
                    node.signalIndicator = signalIndicator; // 保存引用以便后续更新
                }
            }
            
            // 添加ID标签显示
            const idLabel = document.createElement('div');
            idLabel.className = 'component-id-label';
            idLabel.textContent = node.dataset.componentId || '';
            idLabel.style.position = 'absolute';
            idLabel.style.bottom = '-15px';
            idLabel.style.left = '50%';
            idLabel.style.transform = 'translateX(-50%)';
            idLabel.style.color = '#fff';
            idLabel.style.backgroundColor = 'rgba(60, 60, 60, 0.7)';
            idLabel.style.padding = '1px 6px';
            idLabel.style.borderRadius = '8px';
            idLabel.style.fontSize = '10px';
            idLabel.style.fontWeight = 'bold';
            idLabel.style.zIndex = '5';
            node.appendChild(idLabel);
        } else {
            node.className = 'node';
        }
        node.style.left = `${x}px`;
        node.style.top = `${y}px`;
        node.style.background = getComputedStyle(document.documentElement).getPropertyValue('--node-gradient');
        node.dataset.x = x;
        node.dataset.y = y;
        if (iconSrc) {
            const img = document.createElement('img');
            img.src = iconSrc;
            img.alt = iconType || '';
            img.className = 'node-icon-img';
            node.appendChild(img);
            node.dataset.icon = iconType;
        }
        
        // 禁止端口拖动节点，但允许节点双击事件
        node.addEventListener('mousedown', (e) => {
            if (e.target.classList.contains('port')) {
                e.stopPropagation();
                return;
            }
            e.stopPropagation();
            
            // 检查是否在选择模式下，如果是，不启动拖动
            if (isSelectMode) {
                return; // 允许选择模式的mousedown事件处理器处理
            }
            
            if (branchMode) {
                // 检查是否点击了端口
                if(e.target.classList.contains('port')) {
                    branchStart = node;
                    branchStartPort = e.target;
                    return;
                }
                return;
            }
            isDragging = true;
            currentNode = node;
        });
        
        // 移除原始的双击事件，交给setupNodeEvents处理
        
        gridContainer.appendChild(node);
        nodes.push(node);
        return node;
    }
    
    // 优化updateNodesAndBranches性能
    function updateNodesAndBranches() {
        // 预先计算一次更新，批量更新DOM
        const updates = [];
        
        // 收集所有节点位置更新
        nodes.forEach(node => {
            updates.push(() => {
                node.style.left = `${parseInt(node.dataset.x) + panOffset.x}px`;
                node.style.top = `${parseInt(node.dataset.y) + panOffset.y}px`;
                node.style.zIndex = '1'; // 确保节点在连接线上层
            });
        });
        
        // 收集所有连接线更新
        connections.forEach(conn => {
            updates.push(() => updateConnectionPosition(conn));
        });
        
        // 确保连接线在节点下方的DOM位置更新
        connections.forEach(conn => {
            if (conn.element && conn.element.parentNode === gridContainer) {
                updates.push(() => {
                    // 将连接线移动到DOM树的最前面，确保它在组件下层
                    if (gridContainer.firstChild && gridContainer.firstChild !== conn.element) {
                        gridContainer.insertBefore(conn.element, gridContainer.firstChild);
                    }
                });
            }
        });
        
        // 使用requestAnimationFrame批量应用更新
        requestAnimationFrame(() => {
            updates.forEach(update => update());
        });
    }
    
    // 优化拖动性能
    gridContainer.addEventListener('mousemove', function(e) {
        if (branchMode && connectStartPort) {
            // TODO: 可以在这里添加动态显示连接线的功能
        }

        if (isDragging && currentNode) {
            // 拖动节点
            const rect = gridContainer.getBoundingClientRect();
            const x = snapToGridCellCenter(e.clientX - rect.left - panOffset.x);
            const y = snapToGridCellCenter(e.clientY - rect.top - panOffset.y);
            
            // 节流操作 - 只在位置真正改变时才更新
            if (parseInt(currentNode.dataset.x) !== x || parseInt(currentNode.dataset.y) !== y) {
                // 检查新位置是否有效（排除当前节点自己）
                const isValidPosition = !nodes.some(node => {
                    if (node === currentNode) return false; // 排除自己
                    
                    const nodeX = parseInt(node.dataset.x);
                    const nodeY = parseInt(node.dataset.y);
                    
                    const gridSizeValue = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--grid-size'));
                    const minDistance = gridSizeValue * 1.5; // 减小最小距离，使节点可以放置得更近
                    const distance = Math.sqrt(Math.pow(nodeX - x, 2) + Math.pow(nodeY - y, 2));
                    
                    return distance < minDistance;
                });
                
                if (isValidPosition) {
                    // 新位置有效，允许移动
                    showSnapPoint(x + 20, y + 20);
                    setTimeout(hideSnapPoint, 800);
                    currentNode.dataset.x = x;
                    currentNode.dataset.y = y;
                    
                    // 移除不允许放置的视觉提示（如果有的话）
                    currentNode.classList.remove('invalid-position');
                    
                    // 使用requestAnimationFrame提高渲染性能
                    requestAnimationFrame(() => {
                        updateNodesAndBranches();
                        
                        // 发送节点移动事件
                        document.dispatchEvent(new CustomEvent('node-move', {
                            detail: { node: currentNode }
                        }));
                    });
                } else {
                    // 新位置无效，添加视觉提示但不更新位置
                    currentNode.classList.add('invalid-position');
                }
            }
        } else if (isPanning) {
            // 画布平移
            const deltaX = e.clientX - panStart.x;
            const deltaY = e.clientY - panStart.y;
            
            // 节流操作 - 只在位置变化超过一定阈值时更新
            if (Math.abs(deltaX) > 2 || Math.abs(deltaY) > 2) {
                panOffset.x = lastPan.x + deltaX;
                panOffset.y = lastPan.y + deltaY;
                
                // 同步全局panOffset
                window.panOffset = panOffset;
                
                // 使用requestAnimationFrame优化渲染
                requestAnimationFrame(() => {
                    updatePan();
                    
                    // 发送画布更新事件
                    document.dispatchEvent(new CustomEvent('pan-update', {
                        detail: { panOffset: panOffset }
                    }));
                });
            }
        }
    });
    
    // 修改node双击事件监听，提高灵敏度
    function setupNodeEvents() {
        // 为所有节点添加双击事件，提高灵敏度
        const handleNodeDoubleClick = (node) => {
            if(node.dataset.componentType === '开关触发器') {
                // 不再处理开关触发器的双击事件，改为使用右键菜单
                console.log('请右键点击开关触发器以打开控制菜单');
                showToast('请右键点击开关切换状态');
                return true;
            } else if(node.dataset.componentType === '标记储存装置') {
                resetStorage(node);
                return true;
            }
            return false;
        };
        
        // 使用单击加时间戳模拟双击，提高响应速度
        document.addEventListener('click', function(e) {
            const node = e.target.closest('.node');
            if (!node) return;
            
            // 点击灯组件直接返回，不做处理
            if (node.dataset.componentType === '灯') return;
            
            const now = Date.now();
            if (!node.lastClickTime) {
                node.lastClickTime = now;
                return;
            }
            
            // 如果两次点击间隔小于300ms，认为是双击
            if (now - node.lastClickTime < 300) {
                handleNodeDoubleClick(node);
                e.stopPropagation(); // 阻止事件冒泡
                node.lastClickTime = 0; // 重置点击时间，避免连续触发
            } else {
                node.lastClickTime = now;
            }
        });
        
        // 添加右键菜单事件处理，用于设置延时触发器的延时时间
        document.addEventListener('contextmenu', function(e) {
            const node = e.target.closest('.node');
            if (!node) return;
            
            // 阻止默认右键菜单
            e.preventDefault();
            
            // 对延时触发器节点处理右键事件
            if (node.dataset.componentType === '延时触发器') {
                // 如果之前有其他输入框，先移除
                const existingDialog = document.getElementById('delay-time-dialog');
                if (existingDialog) {
                    existingDialog.remove();
                }
                
                // 显示延时设置输入框
                showDelayTimeInput(node, e.clientX, e.clientY);
            }
            // 对开关触发器节点处理右键事件
            else if (node.dataset.componentType === '开关触发器') {
                // 移除可能存在的开关菜单
                const existingMenu = document.getElementById('switch-menu');
                if (existingMenu) {
                    existingMenu.remove();
                }
                
                // 显示开关菜单
                showSwitchMenu(node, e.clientX, e.clientY);
            }
        });
    }
    
    // 触发开关组件 - 优化响应速度
    function toggleSwitch(node) {
        if(!node.state) return;
        
        // 检查是否有实际连接的输入信号为0
        // 首先检查该开关是否有任何连接到它的输入
        const hasInputConnections = connections.some(conn => conn.endNode === node);
        
        // 如果有输入连接，则检查输入值；如果没有连接，则允许自由切换状态
        const hasZeroInput = hasInputConnections ? 
            node.state.inputValues.some(v => v === 0) : false;
        
        // 获取当前开关状态
        const currentActive = node.classList.contains('active');
        
        debugLog(`开关触发操作: 当前状态=${currentActive ? '开启' : '关闭'}, 有输入连接=${hasInputConnections}, 有0信号输入=${hasZeroInput}`);
        
        // 如果当前是关闭状态，尝试激活，需要检查输入条件
        if(!currentActive) {
            // 如果有输入信号为0，不允许激活开关
            if(hasZeroInput) {
                showToast('无法激活开关：输入信号为0');
                debugLog(`开关激活失败：输入信号为0`);
                return; // 提前返回，不允许激活
            }
            
            // 允许激活开关
            if (PERFORMANCE_CONFIG.batchUIUpdates) {
                // 使用requestAnimationFrame批量更新UI，提高性能
                requestAnimationFrame(() => {
            node.classList.add('active');
                    node.state.outputValues[0] = 1; // 打开状态输出1
                    // 更新信号指示器
                    updateSignalIndicator(node, 1);
                });
        } else {
                node.classList.add('active');
                node.state.outputValues[0] = 1; // 打开状态输出1
                // 更新信号指示器
                updateSignalIndicator(node, 1);
            }
            
            debugLog(`开关从关闭状态切换为打开状态，输出: 1`);
        } else {
            // 关闭开关总是允许的
            if (PERFORMANCE_CONFIG.batchUIUpdates) {
                // 使用requestAnimationFrame批量更新UI，提高性能
                requestAnimationFrame(() => {
            node.classList.remove('active');
                    node.state.outputValues[0] = 0; // 关闭状态输出0
                    // 更新信号指示器
                    updateSignalIndicator(node, 0);
                });
            } else {
                node.classList.remove('active');
                node.state.outputValues[0] = 0; // 关闭状态输出0
                // 更新信号指示器
                updateSignalIndicator(node, 0);
            }
            
            debugLog(`开关从打开状态切换为关闭状态，输出: 0`);
        }
        
        // 记录整个电路的状态，仅在调试模式下
        if (PERFORMANCE_CONFIG.debugLogging) {
            logCircuitState();
        }
        
        // 使用新的信号传播方式，避免循环依赖问题
        // 创建一个新的Set用于追踪已访问节点，防止循环
        const visitedNodes = new Set();
        propagateSignal(node, visitedNodes);
    }
    
    // 重置储存器
    function resetStorage(node) {
        if(!node.state || !node.dataset.componentType) return;
        
        const logic = componentLogic[node.dataset.componentType];
        if(logic && logic.reset) {
            node.state.outputValues[0] = logic.reset(node);
            
            // 视觉反馈
            if(node.state.outputValues[0]) {
                node.classList.add('active');
            } else {
                node.classList.remove('active');
            }
            
            // 传播信号变化
            const visitedNodes = new Set();
            propagateSignal(node, visitedNodes);
        }
    }
    
    // 信号传播函数 - 性能优化版本
    function propagateSignal(startNode, visited = new Set()) {
        if (visited.has(startNode)) return;
        visited.add(startNode);
        
        // 获取所有从该节点出发的连接（只考虑正向传播）
        const connectedLines = connections.filter(conn => conn.startNode === startNode);
        
        // 获取组件ID用于日志输出
        const nodeType = startNode.dataset.componentType || 'unknown';
        const nodeId = startNode.dataset.componentId || '';
        const nodeOutput = startNode.state ? startNode.state.outputValues[0] : 'unknown';
        debugLog(`传播信号: ${nodeType}${nodeId}节点, ${connectedLines.length}个连接, 输出值:${nodeOutput}`);
        
        // 优化性能：一次处理多个连接，但避免长时间阻塞
        let processedCount = 0;
        let pendingConnections = [...connectedLines];
        
        const processBatch = () => {
            // 处理一批连接
            const batchSize = Math.min(PERFORMANCE_CONFIG.maxConnectionsPerFrame, pendingConnections.length);
            const batch = pendingConnections.splice(0, batchSize);
            
            batch.forEach(conn => {
                const outputNode = startNode;
                const inputNode = conn.endNode;
                const inputIndex = conn.inputIndex || 0;
                
                // 传递信号
                if (outputNode && outputNode.state && inputNode && inputNode.state) {
                const signalValue = outputNode.state.outputValues[0];
                    
                    // 获取组件ID用于日志
                    const outputType = outputNode.dataset.componentType || 'unknown';
                    const outputId = outputNode.dataset.componentId || '';
                    const inputType = inputNode.dataset.componentType || 'unknown';
                    const inputId = inputNode.dataset.componentId || '';
                    
                    debugLog(`信号传递: ${outputType}${outputId} -> ${inputType}${inputId}[端口${inputIndex}], 值=${signalValue}`);
                    
                    // 更新输入值 - 根据组件类型选择更新方式
                    if (inputNode.dataset.componentType === '与门（&）' || 
                        inputNode.dataset.componentType === 'XOR信号器') {
                        // 对与门和XOR，写入对应inputIndex
                    inputNode.state.inputValues[inputIndex] = signalValue;
                        debugLog(`${inputType}${inputId}更新端口${inputIndex}输入值为${signalValue}, 输入数组现在是[${inputNode.state.inputValues}]`);
                    } else if (inputNode.dataset.componentType === '开关触发器') {
                        // 开关触发器特殊处理 - 只接受信号但不改变其状态
                        // 只记录输入值，但不改变开关状态，避免外部控制开关
                        inputNode.state.inputValues[0] = signalValue;
                        // 更新信号指示器但不改变开关状态
                        if (PERFORMANCE_CONFIG.animationEnabled) {
                            updateSignalIndicator(inputNode, inputNode.state.outputValues[0]);
                        }
                        debugLog(`开关触发器${inputId}接收到输入信号${signalValue}，保持当前状态`);
                        return; // 开关触发器不进行逻辑处理，防止状态被外部控制
                } else {
                        // 其他组件默认使用第一个输入
                    inputNode.state.inputValues[0] = signalValue;
                }
                    
                    // 处理接收节点的逻辑 - 只有当节点类型不是开关触发器时
                processNodeLogic(inputNode, visited);
            }
        });
            
            processedCount += batch.length;
            
            // 如果还有未处理的连接，继续处理下一批
            if (pendingConnections.length > 0) {
                requestAnimationFrame(processBatch);
            }
        };
        
        // 开始处理连接批次
        processBatch();
    }
    
    // 修改processNodeLogic函数，优化与门的信号传播并更新信号指示器
    function processNodeLogic(node, visited = new Set()) {
        if(!node.state || !node.dataset.componentType) return;
        
        const logic = componentLogic[node.dataset.componentType];
        if(!logic) return;
        
        // 获取组件ID用于日志
        const nodeType = node.dataset.componentType;
        const nodeId = node.dataset.componentId || '';
        
        debugLog(`处理节点逻辑: ${nodeType}${nodeId}, 输入值=[${node.state.inputValues.join(',')}]`);
        
        // 特殊处理延时触发器
        if(node.dataset.componentType === '延时触发器') {
            const result = logic.process(node.state.inputValues, node);
            node.state.outputValues[0] = result;
            
            if (PERFORMANCE_CONFIG.batchUIUpdates) {
                requestAnimationFrame(() => {
            if(result) {
                node.classList.add('active');
            } else {
                node.classList.remove('active');
                    }
                    
                    // 更新信号指示器
                    if (PERFORMANCE_CONFIG.animationEnabled) {
                        updateSignalIndicator(node, result);
                    }
                });
            } else {
                if(result) {
                    node.classList.add('active');
                } else {
                    node.classList.remove('active');
                }
                
                // 更新信号指示器
                if (PERFORMANCE_CONFIG.animationEnabled) {
                    updateSignalIndicator(node, result);
                }
            }
            return;
        }
        
        // 灯节点：始终执行process，保证图片和active状态同步
        if(node.dataset.componentType === '灯') {
            logic.process(node.state.inputValues, node);
            // 更新信号指示器
            if (PERFORMANCE_CONFIG.animationEnabled) {
                updateSignalIndicator(node, node.state.inputValues[0] || 0);
        }
            return; // 灯不需要传播信号
        }
        
        // 保存之前的输出状态，用于检测变化
        const prevOutput = node.state.outputValues[0];
        
        // 执行节点的逻辑处理
        const result = logic.process(node.state.inputValues, node);
        node.state.outputValues[0] = result;
        
        debugLog(`${nodeType}${nodeId}处理结果: 输出=${result}, 新状态=${result ? '激活' : '不激活'}`);
        
        // 优化视觉状态更新
        if (PERFORMANCE_CONFIG.batchUIUpdates) {
            requestAnimationFrame(() => {
                // 更新节点的视觉状态
        if(result) {
            node.classList.add('active');
        } else {
            node.classList.remove('active');
        }
                
                // 更新信号指示器
                if (PERFORMANCE_CONFIG.animationEnabled) {
                    updateSignalIndicator(node, result);
                }
            });
        } else {
            // 更新节点的视觉状态
            if(result) {
                node.classList.add('active');
            } else {
                node.classList.remove('active');
            }
            
            // 更新信号指示器
            if (PERFORMANCE_CONFIG.animationEnabled) {
                updateSignalIndicator(node, result);
            }
        }
        
        // 如果输出发生变化，则传播信号
        if (prevOutput !== result) {
            debugLog(`${nodeType}${nodeId}节点输出从${prevOutput}变为${result}，传播信号`);
            
            // 使用更加高效的信号传播方式
            if (PERFORMANCE_CONFIG.useVisitedCache) {
                setTimeout(() => {
                    propagateSignal(node, visited);
                }, 0);
            } else {
                // 对于复杂电路，防止堆栈溢出
                setTimeout(() => {
                    propagateSignal(node, new Set([...visited]));
                }, 0);
            }
        }
    }
    
    // 添加一个新函数用于更新信号指示器 - 优化版本
    function updateSignalIndicator(node, value) {
        if (!node || !node.signalIndicator) return;
        
        // 更新信号指示器文本
        node.signalIndicator.textContent = value ? '1' : '0';
        
        // 根据信号值更新指示器样式 - 减少样式变化次数
        if (value) {
            // 使用transform替代boxShadow可以获得更好的性能
            node.signalIndicator.style.cssText = 
                'background-color: rgba(0, 128, 0, 0.7);' + 
                'box-shadow: 0 0 5px rgba(0, 255, 0, 0.5);';
        } else {
            node.signalIndicator.style.cssText = 
                'background-color: rgba(0, 0, 0, 0.6);' +
                'box-shadow: none;';
        }
    }
    
    // 添加鼠标移动事件检测，在连接模式下实时显示连接线
    gridContainer.addEventListener('mousemove', function(e) {
        if (branchMode && connectStartPort) {
            // TODO: 可以在这里添加动态显示连接线的功能
        }

        if (isDragging && currentNode) {
            // 拖动节点
            const rect = gridContainer.getBoundingClientRect();
            const x = snapToGridCellCenter(e.clientX - rect.left - panOffset.x);
            const y = snapToGridCellCenter(e.clientY - rect.top - panOffset.y);
            
            // 检查新位置是否有效（排除当前节点自己）
            const isValidPosition = !nodes.some(node => {
                if (node === currentNode) return false; // 排除自己
                
                const nodeX = parseInt(node.dataset.x);
                const nodeY = parseInt(node.dataset.y);
                
                const gridSizeValue = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--grid-size'));
                const minDistance = gridSizeValue * 1.5; // 减小最小距离，使节点可以放置得更近
                const distance = Math.sqrt(Math.pow(nodeX - x, 2) + Math.pow(nodeY - y, 2));
                
                return distance < minDistance;
            });
            
            if (isValidPosition) {
                // 新位置有效，允许移动
                showSnapPoint(x + 20, y + 20);
                setTimeout(hideSnapPoint, 800);
                currentNode.dataset.x = x;
                currentNode.dataset.y = y;
                
                // 移除不允许放置的视觉提示（如果有的话）
                currentNode.classList.remove('invalid-position');
            } else {
                // 新位置无效，添加视觉提示但不更新位置
                currentNode.classList.add('invalid-position');
            }
            
            // 更新节点位置和连接线
            updateNodesAndBranches();
            
            // 发送节点移动事件
            document.dispatchEvent(new CustomEvent('node-move', {
                detail: { node: currentNode }
            }));
        } else if (isPanning) {
            // 画布平移
            const deltaX = e.clientX - panStart.x;
            const deltaY = e.clientY - panStart.y;
            panOffset.x = lastPan.x + deltaX;
            panOffset.y = lastPan.y + deltaY;
            
            // 同步全局panOffset
            window.panOffset = panOffset;
            
            // 发送画布更新事件
            document.dispatchEvent(new CustomEvent('pan-update', {
                detail: { panOffset: panOffset }
            }));
            
            updatePan();
        }
    });
    
    function updatePan() {
        // 网格背景平移
        if (gridBg) {
            gridBg.style.backgroundPosition = `${panOffset.x % gridSize}px ${panOffset.y % gridSize}px`;
        }
        // 同步全局panOffset变量
        window.panOffset = panOffset;
        
        // 发送pan-update事件，通知connection.js
        document.dispatchEvent(new CustomEvent('pan-update', {
            detail: { panOffset: panOffset }
        }));
        
        // 打印调试信息
        console.log(`画布偏移更新: x=${panOffset.x}, y=${panOffset.y}`);
        
        updateNodesAndBranches();
    }
    
    function updateNodesAndBranches() {
        // 更新节点位置
        nodes.forEach(node => {
            node.style.left = `${parseInt(node.dataset.x) + panOffset.x}px`;
            node.style.top = `${parseInt(node.dataset.y) + panOffset.y}px`;
            node.style.zIndex = '1'; // 确保节点在连接线上层
        });
        
        // 更新所有连接线
        connections.forEach(conn => {
            updateConnectionPosition(conn);
        });
        
        // 确保连接线在节点下方
        connections.forEach(conn => {
            if (conn.element && conn.element.parentNode === gridContainer) {
                // 将连接线移动到DOM树的最前面，确保它在组件下层
                if (gridContainer.firstChild && gridContainer.firstChild !== conn.element) {
                    gridContainer.insertBefore(conn.element, gridContainer.firstChild);
                }
            }
        });
    }
    
    // 修改鼠标抬起事件，处理连接取消
    document.addEventListener('mouseup', (e) => {
        isPanning = false;
        // 连线模式下点击空白处取消
        if(branchMode && branchStart && !e.target.closest('.node')) {
            branchStart.classList.remove('connecting-start');
            branchStart = null;
        }
        gridContainer.style.cursor = branchMode ? 'pointer' : (nodeMode ? 'crosshair' : 'default');
        isDragging = false;
        currentNode = null;
    });
    
    addNodeBtn.addEventListener('click', () => {
        nodeMode = !nodeMode;
        branchMode = false;
        addNodeBtn.classList.toggle('active', nodeMode);
        addBranchBtn.classList.remove('active');
        gridContainer.style.cursor = nodeMode ? 'crosshair' : 'default';
    });
    
    addBranchBtn.addEventListener('click', () => {
        branchMode = !branchMode;
        nodeMode = false;
        
        // 如果关闭连线模式，清除连接状态
        if (!branchMode && connectingStart) {
            connectingStart.classList.remove('connecting-start');
            connectingStart = null;
        }
        
        addBranchBtn.classList.toggle('active', branchMode);
        addNodeBtn.classList.remove('active');
        gridContainer.style.cursor = branchMode ? 'pointer' : 'default';
        
        console.log('连接模式: ' + (branchMode ? '开启' : '关闭'));
    });
    
    clearBtn.addEventListener('click', () => {
        // 清除节点
        nodes.forEach(node => node.remove());
        nodes = [];
        
        // 清除连接线
        connections.forEach(conn => conn.element.remove());
        connections = [];
        
        // 重置状态
        nodeMode = false;
        branchMode = false;
        
        if (connectingStart) {
            connectingStart.classList.remove('connecting-start');
            connectingStart = null;
        }
        
        addNodeBtn.classList.remove('active');
        addBranchBtn.classList.remove('active');
        
        // 重置组件ID计数器
        Object.keys(componentCounters).forEach(key => {
            componentCounters[key] = 0;
        });
        
        console.log('清空所有元素');
    });
    
    nodeColorInput.addEventListener('input', () => {
        updateColorTheme(nodeColorInput.value);
        updateNodesAndBranches();
    });
    
    // 只能吸附到网格格子的正中心
    function snapToGridCellCenter(value) {
        return Math.floor(value / gridSize) * gridSize + gridSize / 2 - 20; // 40px节点
    }

    // 重新实现拖放功能 - 作为独立功能放在前面，确保优先级最高
    function setupDragAndDrop() {
        console.log('Setting up drag and drop...');
        
        // 创建警告光标样式的元素
        const warningCursor = document.createElement('div');
        warningCursor.className = 'warning-cursor';
        warningCursor.innerHTML = '❌';
        warningCursor.style.display = 'none';
        warningCursor.style.position = 'absolute';
        warningCursor.style.color = 'red';
        warningCursor.style.fontSize = '24px';
        warningCursor.style.pointerEvents = 'none';
        warningCursor.style.zIndex = '1000';
        warningCursor.style.marginLeft = '10px';
        warningCursor.style.marginTop = '-10px';
        document.body.appendChild(warningCursor);
        
        // 设置图标为可拖动
        const sidebarIcons = document.querySelectorAll('.sidebar-icon');
        sidebarIcons.forEach(icon => {
            icon.draggable = true;
            
            icon.addEventListener('dragstart', function(e) {
                console.log('DRAG START:', icon.dataset.icon);
                // 存储被拖动的图标信息
                e.dataTransfer.setData('icon-type', icon.dataset.icon);
                e.dataTransfer.setData('icon-src', icon.src);
                e.dataTransfer.effectAllowed = 'copy';
            });
        });
        
        // 设置网格为拖放区域
        const gridContainer = document.getElementById('grid-container');
        
        // 处理拖动悬停
        gridContainer.addEventListener('dragover', function(e) {
            e.preventDefault();
            
            // 计算网格坐标
            const rect = gridContainer.getBoundingClientRect();
            const x = snapToGridCellCenter(e.clientX - rect.left - panOffset.x);
            const y = snapToGridCellCenter(e.clientY - rect.top - panOffset.y);
            
            // 检查位置是否有效（不与现有节点太近）
            const isValidPosition = checkValidPosition(x, y);
            
            // 显示警告光标
            warningCursor.style.display = 'block';
            warningCursor.style.left = (e.clientX + 10) + 'px';
            warningCursor.style.top = (e.clientY - 10) + 'px';
            
            // 根据位置有效性改变光标和警告标志
            if (isValidPosition) {
                e.dataTransfer.dropEffect = 'copy';
                warningCursor.style.display = 'none';
            } else {
                e.dataTransfer.dropEffect = 'none';
                warningCursor.style.display = 'block';
            }
        });

        // 拖动进入区域
        gridContainer.addEventListener('dragenter', function(e) {
            e.preventDefault();
        });
        
        // 拖动离开区域时隐藏警告光标
        gridContainer.addEventListener('dragleave', function() {
            warningCursor.style.display = 'none';
        });
        
        // 处理拖放
        gridContainer.addEventListener('drop', function(e) {
            e.preventDefault();
            e.stopPropagation();
            
            // 隐藏警告光标
            warningCursor.style.display = 'none';
            
            console.log('DROP EVENT TRIGGERED');
            
            // 获取拖动的图标信息
            const iconType = e.dataTransfer.getData('icon-type');
            const iconSrc = e.dataTransfer.getData('icon-src');
            
            console.log('Dropped icon:', iconType, iconSrc);
            
            if (iconType && iconSrc) {
                // 计算要放置的位置
                const rect = gridContainer.getBoundingClientRect();
                const x = snapToGridCellCenter(e.clientX - rect.left - panOffset.x);
                const y = snapToGridCellCenter(e.clientY - rect.top - panOffset.y);
                
                // 检查是否是有效位置
                if (checkValidPosition(x, y)) {
                    console.log('Creating node at:', x, y);
                    // 创建新节点
                    const newNode = createNode(x, y, iconSrc, iconType);
                    console.log('Node created:', newNode);
                } else {
                    console.log('Invalid position - too close to another node');
                }
            }
        });
        
        // 检查位置是否有效
        function checkValidPosition(x, y) {
            const gridSizeValue = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--grid-size'));
            const minDistance = gridSizeValue * 1.5; // 减小最小距离，使节点可以放置得更近
            
            // 检查是否与现有节点太近
            return !nodes.some(node => {
                const nodeX = parseInt(node.dataset.x);
                const nodeY = parseInt(node.dataset.y);
                const distance = Math.sqrt(Math.pow(nodeX - x, 2) + Math.pow(nodeY - y, 2));
                return distance < minDistance;
            });
        }
        
        console.log('Drag and drop setup complete');
    }

    // 初始化拖放功能 - 确保在最后调用，覆盖任何之前的设置
    setupDragAndDrop();

    // 初始化时同步一次
    updatePan();

    // 添加节点选择和删除操作
    function setupNodeSelection() {
        // 不再添加任何事件处理程序，已由新的选择模式功能替代
        console.log('节点选择和删除功能已由新的多选模式实现');
    }

    // 为端口添加点击事件处理（只在连线模式下生效）
    function setupPortConnections() {
        // 不需要添加任何代码，所有连线处理都由connection.js完成
        console.log('Port connection handling delegated to connection.js');
    }

    // 删除createBranch函数，改用connectionAPI
    function createBranch(startNode, endNode, startPort, endPort, highlight = false) {
        // 如果connectionAPI可用，使用它创建连接
        if (window.connectionAPI && typeof window.connectionAPI.createConnection === 'function') {
            return window.connectionAPI.createConnection(startNode, endNode, startPort, endPort);
        }
        
        console.log('Connection API not available, cannot create connection');
        return null;
    }

    // 初始化端口连接功能
    setupPortConnections();

    // 修改鼠标点击事件处理逻辑，防止灯作为连接起点
    gridContainer.addEventListener('click', function(e) {
        // 只在连接模式下处理
        if (!branchMode) return;
        
        console.log('连线模式中，处理点击事件');
        
        // 查找被点击的节点（可能是节点的子元素）
        const clickedElement = e.target;
        const node = clickedElement.closest('.node');
        
        if (!node) {
            // 点击了空白区域，取消连接
            if (connectingStart) {
                connectingStart.classList.remove('connecting-start');
                connectingStart = null;
                console.log('连接取消 - 点击空白区域');
            }
            return;
        }
        
        // 点击了节点
        if (!connectingStart) {
            // 第一次点击，检查是否为灯
            if (node.dataset.componentType === '灯') {
                showToast('灯只能接收信号，不能作为连接起点！');
                console.log('连接失败 - 灯不能作为起点');
                return;
            }
            
            // 正常设置起点
            connectingStart = node;
            node.classList.add('connecting-start');
            console.log('连接起点设置:', node.dataset.componentType || '普通节点');
        } 
        else if (node !== connectingStart) {
            // 灯只能作为终点，不能成为起点
            if (connectingStart.dataset.componentType === '灯') {
                showToast('灯只能接收信号，不能作为连接起点！');
                connectingStart.classList.remove('connecting-start');
                connectingStart = null;
                console.log('连接失败 - 灯不能作为起点');
                return;
            }
            
            // 第二次点击不同节点
            // 检查这两个节点之间是否已经存在连接
            const existingConnection = connections.find(conn => 
                (conn.startNode === connectingStart && conn.endNode === node) ||
                (conn.startNode === node && conn.endNode === connectingStart)
            );
            
            if (existingConnection) {
                // 已存在连接，删除它
                console.log('发现已存在连接，正在删除...');
                
                // 从DOM中移除连接线
                existingConnection.element.remove();
                
                // 从connections数组中移除
                const connectionIndex = connections.indexOf(existingConnection);
                if (connectionIndex !== -1) {
                    connections.splice(connectionIndex, 1);
                }
                
                // 清除可能受影响的输入值
                if (existingConnection.endNode.state && existingConnection.endNode.state.inputValues) {
                    // 清除对应的输入值
                    existingConnection.endNode.state.inputValues[existingConnection.inputIndex] = undefined;
                    console.log(`清除节点 ${existingConnection.endNode.dataset.componentType} 的输入值[${existingConnection.inputIndex}]`);
                    
                    // 重新处理节点逻辑
                    processNodeLogic(existingConnection.endNode, new Set());
                }
                
                showToast('连接已删除');
                logCircuitState();
            } else {
                // 不存在连接，尝试直接调用createGlowConnection创建新连接
                console.log('尝试创建连接:', 
                       connectingStart.dataset.componentType || '起点', 
                       '->', 
                       node.dataset.componentType || '终点');
                
                createGlowConnection(connectingStart, node);
            }
            
            // 重置连接状态
            connectingStart.classList.remove('connecting-start');
            connectingStart = null;
        }
        else {
            // 点击同一节点，取消连接
            connectingStart.classList.remove('connecting-start');
            connectingStart = null;
            console.log('连接取消 - 点击相同节点');
        }
    });

    // 创建连接线
    function getPortType(node) {
        if (!node || !node.dataset || !node.dataset.componentType) return 'unknown';
        
        const componentType = node.dataset.componentType;
        
        // 只有输出的组件
        if (componentType === '非门（NOT）' || 
            componentType === '分支（BR）' || 
            componentType === '与门（&）' || 
            componentType === 'XOR信号器' || 
            componentType === '或门（OR）' ||
            componentType === '开关触发器') return 'output';
        
        // 只有输入的组件
        if (componentType === '灯') return 'input';
        
        // 既有输入又有输出的组件
        if (componentType === '延时触发器' || 
            componentType === '标记储存装置') {
            return 'both';
        }
        
        return 'unknown';
    }

    function createConnection(startNode, endNode) {
        // 先检查是否有灯作为起点，这种情况禁止
        if (startNode.dataset.componentType === '灯') {
            showToast('灯只能接收信号，不能作为信号源！');
            console.log('创建连接失败: 灯不能作为连接起点');
            return null;
        }
        
        // 手动确定端口类型
        let startType = 'unknown';
        let endType = 'unknown';
        
        // 确定起点类型
        const startComponentType = startNode.dataset.componentType;
        if (startComponentType === '非门（NOT）' || 
            startComponentType === '分支（BR）' || 
            startComponentType === '与门（&）' || 
            startComponentType === 'XOR信号器' || 
            startComponentType === '或门（OR）') {
            startType = 'output';
        } else if (startComponentType === '灯') {
            startType = 'input';
        } else if (startComponentType === '延时触发器' || 
                   startComponentType === '标记储存装置' ||
                   startComponentType === '开关触发器') { // 开关触发器可以作为输入和输出
            startType = 'both';
        }
        
        // 确定终点类型
        const endComponentType = endNode.dataset.componentType;
        if (endComponentType === '非门（NOT）' || 
            endComponentType === '分支（BR）' || 
            endComponentType === '与门（&）' || 
            endComponentType === 'XOR信号器' || 
            endComponentType === '或门（OR）') {
            endType = 'output';
        } else if (endComponentType === '灯') {
            endType = 'input';
        } else if (endComponentType === '延时触发器' || 
                   endComponentType === '标记储存装置' ||
                   endComponentType === '开关触发器') { // 开关触发器可以作为输入和输出
            endType = 'both';
        }
        
        // 处理'both'类型的端口
        if (startType === 'both') {
            // 如果终点是输入端，则起点作为输出端
            if (endType === 'input') {
                startType = 'output';
            }
            // 如果终点是输出端，则起点作为输入端
            else if (endType === 'output') {
                startType = 'input';
            }
            // 如果终点也是'both'，默认起点作为输出端，终点作为输入端
            else if (endType === 'both') {
                startType = 'output';
                endType = 'input';
            }
        }
        else if (endType === 'both') {
            // 如果起点是输入端，则终点作为输出端
            if (startType === 'input') {
                endType = 'output';
            }
            // 如果起点是输出端，则终点作为输入端
            else if (startType === 'output') {
                endType = 'input';
            }
        }
        
        // 特殊处理：允许从与门连接到开关触发器
        if (endComponentType === '开关触发器' && startType === 'output') {
            endType = 'input';
            console.log('允许连接到开关触发器');
        }
        
        // 检查连接是否合法：输出->输入
        if (startType !== 'output' || endType !== 'input') {
            showToast('连接必须从输出端连接到输入端！');
            console.log(`连接失败: ${startComponentType}(${startType}) -> ${endComponentType}(${endType})`);
            return null;
        }
        
        // 禁止两个灯之间相互连接
        if (startComponentType === '灯' && endComponentType === '灯') {
            showToast('灯只能接收信号，不能互相连接！');
            return null;
        }
        
        // 端口类型调整后再判断灯的输入端口
        if (endComponentType === '灯') {
            if (connections.some(conn => conn.endNode === endNode)) {
                showToast('灯只能有一个输入端口！');
                return null;
            }
        }
        // 非门输入连接数量限制（最多1个）
        if (endComponentType === '非门（NOT）') {
            if (connections.some(conn => conn.endNode === endNode)) {
                showToast('非门只能有一个输入端口！');
                return null;
            }
        }
        // XOR信号器输入连接数量限制（最多2个）
        if (endComponentType === 'XOR信号器') {
            const inputConnections = connections.filter(conn => conn.endNode === endNode);
            if (inputConnections.length >= 2) {
                showToast('XOR信号器最多只能有2个输入连接！');
                return null;
            }
        }
        // 延时触发器输入连接数量限制（最多1个）
        if (endComponentType === '延时触发器') {
            if (connections.some(conn => conn.endNode === endNode)) {
                showToast('延时触发器只能有一个输入端口！');
                return null;
            }
        }
        // 标记储存装置输入连接数量限制（最多2个）
        if (endComponentType === '标记储存装置') {
            const inputConnections = connections.filter(conn => conn.endNode === endNode);
            if (inputConnections.length >= 2) {
                showToast('标记储存装置最多只能有2个输入端口！');
                return null;
            }
        }
        // 分支输入连接数量限制（最多1个）
        if (endComponentType === '分支（BR）') {
            if (connections.some(conn => conn.endNode === endNode)) {
                showToast('分支只能有一个输入端口！');
                return null;
            }
        }
        // 开关触发器输入连接数量限制（最多1个）
        if (endComponentType === '开关触发器') {
            const inputConnections = connections.filter(conn => conn.endNode === endNode);
            if (inputConnections.length >= 1) {
                showToast('开关触发器最多只能有1个输入连接！');
                return null;
            }
        }
        // 开关触发器输出连接数量限制（最多1个）
        if (startComponentType === '开关触发器') {
            const outputConnections = connections.filter(conn => conn.startNode === startNode);
            if (outputConnections.length >= 1) {
                showToast('开关触发器最多只能有1个输出连接！');
                return null;
            }
        }
        
        // 检查是否已存在相同的连接
        if (connections.some(conn => 
            (conn.startNode === startNode && conn.endNode === endNode) ||
            (conn.startNode === endNode && conn.endNode === startNode))) {
            console.log('连接已存在!');
            showToast('连接已存在');
            return null;
        }
        
        let inputIndex = 0;
        // 如果终点是与门，分配唯一inputIndex
        if (endComponentType === '与门（&）') {
            if (endNode.state && Array.isArray(endNode.state.inputValues)) {
                // 找到第一个未被占用的位置
                for (let i = 0; i < endNode.state.inputValues.length; i++) {
                    if (endNode.state.inputValues[i] === undefined) {
                        inputIndex = i;
                        break;
                    }
                    // 如果都被占用，则扩展
                    if (i === endNode.state.inputValues.length - 1) {
                        endNode.state.inputValues.push(undefined);
                        inputIndex = endNode.state.inputValues.length - 1;
                    }
                }
            }
        }
        // XOR信号器需要特殊处理，确保两个输入端口正确分配
        else if (endComponentType === 'XOR信号器') {
            // 查找已经连接到该XOR的连接
            const xorConnections = connections.filter(conn => conn.endNode === endNode);
            
            if (xorConnections.length === 0) {
                // 第一个连接，使用端口0
                inputIndex = 0;
                console.log('XOR信号器: 首个连接，使用输入端口0');
            } else if (xorConnections.length === 1) {
                // 第二个连接，使用端口1
                inputIndex = 1;
                console.log('XOR信号器: 第二个连接，使用输入端口1');
            } else {
                // 已有两个连接，显示警告
                showToast('XOR信号器最多只能有2个输入连接');
                console.log('XOR信号器已有2个输入，拒绝新连接');
                return null;
            }
        }
        
        // 创建连接线元素
        const line = document.createElement('div');
        line.className = 'branch active';
        line.style.position = 'absolute';
        line.style.height = '2px'; // 从3px减小到2px
        line.style.transformOrigin = 'left center';
        line.style.backgroundColor = '#3ddad7';
        line.style.boxShadow = '0 0 5px #3ddad7, 0 0 10px rgba(61,218,215,0.2)'; // 减小发光范围和强度
        line.style.borderRadius = '1px'; // 与高度匹配
        line.style.zIndex = '0';
        
        const firstChild = gridContainer.firstChild;
        if (firstChild) {
            gridContainer.insertBefore(line, firstChild);
        } else {
            gridContainer.appendChild(line);
        }
        
        // 创建连接对象，记录inputIndex
        const connection = {
            element: line,
            startNode: startNode,
            endNode: endNode,
            inputIndex: (endComponentType === '与门（&）' || 
                         endComponentType === 'XOR信号器') ? inputIndex : 0
        };
        
        updateConnectionPosition(connection);
        connections.push(connection);
        showToast('连接成功');
        
        // 连接建立后，立即传递起始节点的信号状态到终点节点
        if (startNode.state && endNode.state) {
            const signalValue = startNode.state.outputValues[0];
            console.log(`连接建立: ${startComponentType} -> ${endComponentType}, 初始信号值: ${signalValue}`);
            
            // 根据节点类型更新输入值
            if (endComponentType === '与门（&）') {
                // 如果起始节点是开关触发器，需要根据开关状态决定传递的信号值
                if (startComponentType === '开关触发器') {
                    const isActive = startNode.classList.contains('active');
                    endNode.state.inputValues[inputIndex] = isActive ? 1 : 0;
                    console.log(`开关触发器 -> 与门: 传递信号 ${isActive ? 1 : 0}`);
                    
                    // 更新开关和与门的信号指示器
                    updateSignalIndicator(startNode, isActive ? 1 : 0);
                    
                    // 处理与门逻辑后更新其信号指示器
                    processNodeLogic(endNode);
                } else {
                    endNode.state.inputValues[inputIndex] = signalValue;
                    
                    // 更新起始节点和与门的信号指示器
                    updateSignalIndicator(startNode, signalValue);
                    
                    // 处理与门逻辑后更新其信号指示器
                    processNodeLogic(endNode);
                }
            } else if (endComponentType === '标记储存装置') {
                // 不再根据result.inputIndex确定控制端和输入端
                // 只需传递信号，标记储存装置的process函数会根据信号先后顺序识别控制端和输入端
                if (startComponentType === '开关触发器') {
                    const isActive = startNode.classList.contains('active');
                    // 根据开关状态设置输入值
                    endNode.state.inputValues[inputIndex] = isActive ? 1 : 0;
                    console.log(`开关触发器 -> 标记储存装置: 传递信号 ${isActive ? 1 : 0}`);
                    
                    // 更新开关的信号指示器
                    updateSignalIndicator(startNode, isActive ? 1 : 0);
                } else {
                    // 传递其他组件的信号
                    endNode.state.inputValues[inputIndex] = signalValue;
                    console.log(`${startComponentType} -> 标记储存装置: 传递信号 ${signalValue}`);
                    
                    // 更新起始节点的信号指示器
                    updateSignalIndicator(startNode, signalValue);
                }
            } else {
                // 如果起始节点是开关触发器，需要根据开关状态决定传递的信号值
                if (startComponentType === '开关触发器') {
                    const isActive = startNode.classList.contains('active');
                    endNode.state.inputValues[0] = isActive ? 1 : 0;
                    console.log(`开关触发器 -> ${endComponentType}: 传递信号 ${isActive ? 1 : 0}`);
                    
                    // 更新开关的信号指示器
                    updateSignalIndicator(startNode, isActive ? 1 : 0);
                } else {
                    endNode.state.inputValues[0] = signalValue;
                    
                    // 更新起始节点的信号指示器
                    updateSignalIndicator(startNode, signalValue);
                }
            }
            
            // 处理接收节点的逻辑
                    processNodeLogic(endNode);
            
            // 如果起始节点是开关且处于激活状态，确保信号传播
            if (startComponentType === '开关触发器') {
                if (startNode.classList.contains('active')) {
                    console.log(`开关触发器处于打开状态，传播信号1`);
                    propagateSignal(startNode, new Set());
                } else {
                    console.log(`开关触发器处于关闭状态，不传播信号`);
                }
            } else {
                // 其他类型的节点，正常传播信号
                propagateSignal(startNode, new Set());
            }
        }
        
        // 连接成功后记录电路状态
        console.log(`成功创建连接: [${startComponentType}] -> [${endComponentType}]`);
        logCircuitState();
        
            // 自动退出连线模式
            branchMode = false;
            connectingStart = null;
            gridContainer.style.cursor = 'default';
            document.body.classList.remove('connection-mode');
            setCtrlIconActive(false);
            document.querySelectorAll('.connecting-start').forEach(node => {
                node.classList.remove('connecting-start');
            });
            document.querySelectorAll('.selected-input, .selected-output').forEach(node => {
                node.classList.remove('selected-input', 'selected-output');
            });
        
        return connection;
    }

    // 更新连接线位置
    function updateConnectionPosition(connection) {
        if (!connection || !connection.element || 
            !connection.startNode || !connection.endNode) {
            return;
        }
        
        const line = connection.element;
        const startNode = connection.startNode;
        const endNode = connection.endNode;
        
        try {
            // 获取节点位置
            const startX = parseInt(startNode.dataset.x) + panOffset.x;
            const startY = parseInt(startNode.dataset.y) + panOffset.y;
            const endX = parseInt(endNode.dataset.x) + panOffset.x;
            const endY = parseInt(endNode.dataset.y) + panOffset.y;
            
            // 节点宽高
            const nodeWidth = startNode.offsetWidth || 40;
            const nodeHeight = startNode.offsetHeight || 40;
            
            // 计算中心点
            const centerStartX = startX + nodeWidth / 2;
            const centerStartY = startY + nodeHeight / 2;
            const centerEndX = endX + nodeWidth / 2;
            const centerEndY = endY + nodeHeight / 2;
            
            // 计算线条长度和角度
            const length = Math.sqrt(
                Math.pow(centerEndX - centerStartX, 2) + 
                Math.pow(centerEndY - centerStartY, 2)
            );
            const angle = Math.atan2(
                centerEndY - centerStartY, 
                centerEndX - centerStartX
            ) * 180 / Math.PI;
            
            // 更新线条样式
            line.style.left = `${centerStartX}px`;
            line.style.top = `${centerStartY}px`;
            line.style.width = `${length}px`;
            line.style.transform = `rotate(${angle}deg)`;
            line.style.zIndex = '0'; // 确保连接线在组件下层
            
            // 确保线条可见
            line.style.visibility = 'visible';
            line.style.display = 'block';
            
            // 确保线条在DOM中的位置是在组件下层
            if (line.parentNode === gridContainer) {
                // 将线条移动到DOM树的最前面，确保它在组件下层
                if (gridContainer.firstChild && gridContainer.firstChild !== line) {
                    gridContainer.insertBefore(line, gridContainer.firstChild);
                }
            }
            
        } catch (error) {
            console.error('更新连接线出错:', error);
        }
    }

    // SVG拖拽连线功能
    let dragInfo = null;
    let svgLayer = document.getElementById('connection-svg');
    if (!svgLayer) {
        svgLayer = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
        svgLayer.classList.add('connection-svg');
        svgLayer.setAttribute('id', 'connection-svg');
        svgLayer.style.position = 'absolute';
        svgLayer.style.left = '0'; svgLayer.style.top = '0';
        svgLayer.style.width = '100%'; svgLayer.style.height = '100%';
        svgLayer.style.pointerEvents = 'none';
        svgLayer.style.zIndex = '0';
        document.getElementById('grid-container').appendChild(svgLayer);
    }
    window.svgLayer = svgLayer; // 全局可用

    // 端口mousedown
    function onPortMouseDown(e) {
        if (!e.target.classList.contains('input-port') && !e.target.classList.contains('output-port')) return;
        const port = e.target;
        const node = port.closest('.node');
        const portType = port.classList.contains('input-port') ? 'input' : 'output';
        const portRect = port.getBoundingClientRect();
        const gridRect = document.getElementById('grid-container').getBoundingClientRect();
        const startX = portRect.left + portRect.width/2 - gridRect.left;
        const startY = portRect.top + portRect.height/2 - gridRect.top;

        // 创建临时SVG线
        const tempPath = document.createElementNS('http://www.w3.org/2000/svg', 'path');
        tempPath.setAttribute('class', 'temp-branch');
        svgLayer.appendChild(tempPath);

        dragInfo = { startNode: node, startPort: port, startType: portType, startX, startY, tempPath };

        document.addEventListener('mousemove', onPortMouseMove);
        document.addEventListener('mouseup', onPortMouseUp);
    }

    document.addEventListener('mousedown', onPortMouseDown);

    function onPortMouseMove(e) {
        if (!dragInfo) return;
        const svgRect = svgLayer.getBoundingClientRect();
        const mouseX = e.clientX - svgRect.left;
        const mouseY = e.clientY - svgRect.top;

        // 贝塞尔控制点
        const c1x = dragInfo.startX + (dragInfo.startType === 'output' ? 60 : -60);
        const c2x = mouseX + (dragInfo.startType === 'output' ? -60 : 60);
        const d = `M${dragInfo.startX},${dragInfo.startY} C${c1x},${dragInfo.startY} ${c2x},${mouseY} ${mouseX},${mouseY}`;
        dragInfo.tempPath.setAttribute('d', d);

        // 判断目标节点及左右半区
        let highlightNode = null;
        document.querySelectorAll('.node').forEach(node => {
            const rect = node.getBoundingClientRect();
            if (
                e.clientX >= rect.left && e.clientX <= rect.right &&
                e.clientY >= rect.top && e.clientY <= rect.bottom
            ) {
                highlightNode = node;
                const isRight = (e.clientX - rect.left) > rect.width / 2;
                if (isRight) {
                    node.classList.add('highlight-right');
                    node.classList.remove('forbid-left');
                    document.body.style.cursor = 'pointer';
                } else {
                    node.classList.remove('highlight-right');
                    node.classList.add('forbid-left');
                    document.body.style.cursor = 'not-allowed';
                }
            } else {
                node.classList.remove('highlight-right', 'forbid-left');
            }
        });
        if (!highlightNode) document.body.style.cursor = '';
    }

    function onPortMouseUp(e) {
        if (!dragInfo) return;
        let connected = false;
        document.querySelectorAll('.node').forEach(node => {
            const rect = node.getBoundingClientRect();
            if (
                e.clientX >= rect.left && e.clientX <= rect.right &&
                e.clientY >= rect.top && e.clientY <= rect.bottom
            ) {
                const isRight = (e.clientX - rect.left) > rect.width / 2;
                if (isRight && node !== dragInfo.startNode) {
                    // 创建正式逻辑连接和高亮连线
                    createGlowConnection(dragInfo.startNode, node);
                    connected = true;
                }
            }
            node.classList.remove('highlight-right', 'forbid-left');
        });
        dragInfo.tempPath.remove();
        dragInfo = null;
        document.body.style.cursor = '';
        document.removeEventListener('mousemove', onPortMouseMove);
        document.removeEventListener('mouseup', onPortMouseUp);
    }

    function createSVGConnection(startNode, endNode, startPort, endPort) {
        // 计算起点终点
        const gridRect = document.getElementById('grid-container').getBoundingClientRect();
        const startRect = startPort.getBoundingClientRect();
        const endRect = endPort.getBoundingClientRect();
        const x1 = startRect.left + startRect.width/2 - gridRect.left;
        const y1 = startRect.top + startRect.height/2 - gridRect.top;
        const x2 = endRect.left + endRect.width/2 - gridRect.left;
        const y2 = endRect.top + endRect.height/2 - gridRect.top;
        const c1x = x1 + 60, c2x = x2 - 60;
        const d = `M${x1},${y1} C${c1x},${y1} ${c2x},${y2} ${x2},${y2}`;
        const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
        path.setAttribute('class', 'branch-path');
        path.setAttribute('d', d);
        svgLayer.appendChild(path);
    }

    // div直线连线功能
    let dragLineDiv = null;
    let dragStart = null;

    // 端口mousedown事件
    function onDivPortMouseDown(e) {
        if (!e.target.classList.contains('input-port') && !e.target.classList.contains('output-port')) return;
        const port = e.target;
        const node = port.closest('.node');
        const portRect = port.getBoundingClientRect();
        const gridRect = document.getElementById('grid-container').getBoundingClientRect();
        const startX = portRect.left + portRect.width/2 - gridRect.left;
        const startY = portRect.top + portRect.height/2 - gridRect.top;

        dragStart = { node, port, x: startX, y: startY };

        // 创建临时线
        dragLineDiv = document.createElement('div');
        dragLineDiv.className = 'temp-branch';
        dragLineDiv.style.left = `${startX}px`;
        dragLineDiv.style.top = `${startY}px`;
        document.getElementById('grid-container').appendChild(dragLineDiv);

        document.addEventListener('mousemove', onDragLineMove);
        document.addEventListener('mouseup', onDragLineUp);
    }

    document.getElementById('grid-container').addEventListener('mousedown', onDivPortMouseDown);

    function onDragLineMove(e) {
        if (!dragLineDiv || !dragStart) return;
        const gridRect = document.getElementById('grid-container').getBoundingClientRect();
        const mouseX = e.clientX - gridRect.left;
        const mouseY = e.clientY - gridRect.top;
        const dx = mouseX - dragStart.x;
        const dy = mouseY - dragStart.y;
        const length = Math.sqrt(dx*dx + dy*dy);
        const angle = Math.atan2(dy, dx) * 180 / Math.PI;
        dragLineDiv.style.width = `${length}px`;
        dragLineDiv.style.transform = `rotate(${angle}deg)`;
    }

    function onDragLineUp(e) {
        if (!dragLineDiv || !dragStart) return;
        // 判断是否在目标节点右半边
        let connected = false;
        document.querySelectorAll('.node').forEach(node => {
            const rect = node.getBoundingClientRect();
            if (
                e.clientX >= rect.left && e.clientX <= rect.right &&
                e.clientY >= rect.top && e.clientY <= rect.bottom
            ) {
                const isRight = (e.clientX - rect.left) > rect.width / 2;
                if (isRight && node !== dragStart.node) {
                    // 创建正式连线
                    createDivConnection(dragStart, node, rect, document.getElementById('grid-container').getBoundingClientRect());
                    connected = true;
                }
            }
        });
        dragLineDiv.remove();
        dragLineDiv = null;
        dragStart = null;
        document.removeEventListener('mousemove', onDragLineMove);
        document.removeEventListener('mouseup', onDragLineUp);
    }

    function createDivConnection(start, endNode, endRect, gridRect) {
        // 不再直接创建连接线，而是调用createGlowConnection函数
        if (start && start.node && endNode) {
            // 使用createGlowConnection创建连接线
            return createGlowConnection(start.node, endNode);
        }
        
        // 如果无法使用createGlowConnection，则显示提示
        console.error('无法创建连接：起点或终点节点不存在');
        showToast('连接失败：节点信息不完整');
        return null;
    }

    // 高亮div直线连接功能
    let connectMode = null; // 'input' or 'output'
    let connectNode = null;

    gridContainer.addEventListener('mousedown', function(e) {
        console.log('mousedown', e.button, e.target);
        if (!e.target.classList.contains('node') && !e.target.closest('.node')) return;
        const node = e.target.classList.contains('node') ? e.target : e.target.closest('.node');
        
        // 检查是否为灯组件
        if (node.dataset.componentType === '灯') {
            showToast('灯只能接收信号，不能作为连接起点！');
            console.log('灯不能作为连接起点');
            return;
        }
        
        if (e.button === 0) { // 左键
            connectMode = 'output';
            connectNode = node;
            node.classList.add('selected-output');
            console.log('激活输出端', node);
        }
        // 删除右键点击设置为input模式的代码
    });

    gridContainer.addEventListener('mouseup', function(e) {
        console.log('mouseup', e.button, e.target);
        if (!connectMode || !connectNode) return;
        if (!e.target.classList.contains('node') && !e.target.closest('.node')) return;
        const targetNode = e.target.classList.contains('node') ? e.target : e.target.closest('.node');
        if (targetNode === connectNode) return; // 不允许自连

        if (connectMode === 'output') {
            // 当前输出到目标输入（connectNode → targetNode）
            createGlowConnection(connectNode, targetNode);
        }
        connectNode.classList.remove('selected-input', 'selected-output');
        connectMode = null;
        connectNode = null;
    });

    gridContainer.addEventListener('contextmenu', e => e.preventDefault());

    function createGlowConnection(startNode, endNode) {
        console.log('createGlowConnection called', startNode, endNode);
        
        // 灯不能作为起点，这是基本限制
        if (startNode.dataset.componentType === '灯') {
            showToast('灯只能接收信号，不能作为信号源！');
            console.log('连接失败 - 灯不能作为起点');
            return null;
        }
        
        // 检查是否已存在相同的连接
        const existingConnection = connections.find(conn => 
            (conn.startNode === startNode && conn.endNode === endNode)
        );
        
        if (existingConnection) {
            console.log('连接已存在，不重复创建');
            showToast('连接已存在');
            return existingConnection;
        }
        
        // 执行专门的连接合法性检查
        // 灯只能作为终点，而且只能有一个输入
        if (endNode.dataset.componentType === '灯' && connections.some(conn => conn.endNode === endNode)) {
            showToast('灯只能有一个输入端口！');
            console.log('连接失败 - 灯已有输入连接');
            return null;
        }
        
        // 非门输入连接数量限制（最多1个）
        if (endNode.dataset.componentType === '非门（NOT）' && connections.some(conn => conn.endNode === endNode)) {
            showToast('非门只能有一个输入端口！');
            console.log('连接失败 - 非门已有输入连接');
            return null;
        }
        
        // XOR信号器输入连接数量限制（最多2个）
        if (endNode.dataset.componentType === 'XOR信号器') {
            const inputConnections = connections.filter(conn => conn.endNode === endNode);
            if (inputConnections.length >= 2) {
                showToast('XOR信号器最多只能有2个输入连接！');
                console.log('连接失败 - XOR信号器已有2个输入连接');
                return null;
            }
        }
        
        // 延时触发器输入连接数量限制（最多1个）
        if (endNode.dataset.componentType === '延时触发器' && connections.some(conn => conn.endNode === endNode)) {
            showToast('延时触发器只能有一个输入端口！');
            console.log('连接失败 - 延时触发器已有输入连接');
            return null;
        }
        
        // 标记储存装置输入连接数量限制（最多2个）
        if (endNode.dataset.componentType === '标记储存装置') {
            const inputConnections = connections.filter(conn => conn.endNode === endNode);
            if (inputConnections.length >= 2) {
                showToast('标记储存装置最多只能有2个输入端口！');
                console.log('连接失败 - 标记储存装置已有2个输入连接');
                return null;
            }
        }
        
        // 分支输入连接数量限制（最多1个）
        if (endNode.dataset.componentType === '分支（BR）' && connections.some(conn => conn.endNode === endNode)) {
            showToast('分支只能有一个输入端口！');
            console.log('连接失败 - 分支已有输入连接');
            return null;
        }
        
        // 开关触发器输入/输出连接数量限制
        if (endNode.dataset.componentType === '开关触发器' && connections.some(conn => conn.endNode === endNode)) {
            showToast('开关触发器最多只能有1个输入连接！');
            console.log('连接失败 - 开关触发器已有输入连接');
            return null;
        }
        
        if (startNode.dataset.componentType === '开关触发器' && connections.some(conn => conn.startNode === startNode)) {
            showToast('开关触发器最多只能有1个输出连接！');
            console.log('连接失败 - 开关触发器已有输出连接');
            return null;
        }
        
        // 创建连接线视觉元素
        const gridRect = gridContainer.getBoundingClientRect();
        const startRect = startNode.getBoundingClientRect();
        const endRect = endNode.getBoundingClientRect();
        const x1 = startRect.left + startRect.width/2 - gridRect.left;
        const y1 = startRect.top + startRect.height/2 - gridRect.top;
        const x2 = endRect.left + endRect.width/2 - gridRect.left;
        const y2 = endRect.top + endRect.height/2 - gridRect.top;
        const dx = x2 - x1, dy = y2 - y1;
        const length = Math.sqrt(dx*dx + dy*dy);
        const angle = Math.atan2(dy, dx) * 180 / Math.PI;
        
        // 创建连接线元素
        const branch = document.createElement('div');
        branch.className = 'glow-branch branch'; // 添加branch类以便识别
        branch.style.left = `${x1}px`;
        branch.style.top = `${y1}px`;
        branch.style.width = `${length}px`;
        branch.style.transform = `rotate(${angle}deg)`;
        branch.style.height = '2px'; // 从默认的3px减小到2px
        branch.style.backgroundColor = '#3ddad7';
        branch.style.boxShadow = '0 0 5px #3ddad7, 0 0 10px rgba(61,218,215,0.2)'; // 减小发光范围和强度
        branch.style.borderRadius = '1px'; // 与高度匹配
        branch.style.zIndex = '0'; // 确保连接线在组件下层
        branch.style.cursor = 'pointer'; // 添加指针样式，提示可点击
        
        // 将连接线插入到网格容器的最前面，确保它在组件下层
        if (gridContainer.firstChild) {
            gridContainer.insertBefore(branch, gridContainer.firstChild);
        } else {
        gridContainer.appendChild(branch);
        }
        
        // 决定输入索引
        let inputIndex = 0;
        // 如果终点是与门，分配唯一inputIndex
        if (endNode.dataset.componentType === '与门（&）') {
            if (endNode.state && Array.isArray(endNode.state.inputValues)) {
                // 找到第一个未被占用的位置
                for (let i = 0; i < endNode.state.inputValues.length; i++) {
                    if (endNode.state.inputValues[i] === undefined) {
                        inputIndex = i;
                        break;
                    }
                    // 如果都被占用，则扩展
                    if (i === endNode.state.inputValues.length - 1) {
                        endNode.state.inputValues.push(undefined);
                        inputIndex = endNode.state.inputValues.length - 1;
                    }
                }
            }
        }
        // XOR信号器需要特殊处理，确保两个输入端口正确分配
        else if (endComponentType === 'XOR信号器') {
            // 查找已经连接到该XOR的连接
            const xorConnections = connections.filter(conn => conn.endNode === endNode);
            
            if (xorConnections.length === 0) {
                // 第一个连接，使用端口0
                inputIndex = 0;
                console.log('XOR信号器: 首个连接，使用输入端口0');
            } else if (xorConnections.length === 1) {
                // 第二个连接，使用端口1
                inputIndex = 1;
                console.log('XOR信号器: 第二个连接，使用输入端口1');
            } else {
                // 已有两个连接，显示警告
                showToast('XOR信号器最多只能有2个输入连接');
                console.log('XOR信号器已有2个输入，拒绝新连接');
                return null;
            }
        }
        
        // 创建连接对象，记录inputIndex
        const connection = {
            element: branch,
            startNode: startNode,
            endNode: endNode,
            inputIndex: (endNode.dataset.componentType === '与门（&）' || 
                         endNode.dataset.componentType === 'XOR信号器') ? inputIndex : 0
        };
        
        // 更新连接位置
        updateConnectionPosition(connection);
        connections.push(connection);
            showToast('连接成功');
            
        // 连接建立后，立即传递起始节点的信号状态到终点节点
        if (startNode.state && endNode.state) {
            const signalValue = startNode.state.outputValues[0];
            console.log(`连接建立: ${startNode.dataset.componentType} -> ${endNode.dataset.componentType}, 初始信号值: ${signalValue}`);
            
            // 根据节点类型更新输入值
            if (endNode.dataset.componentType === '与门（&）') {
                // 如果起始节点是开关触发器，需要根据开关状态决定传递的信号值
                if (startNode.dataset.componentType === '开关触发器') {
                    const isActive = startNode.classList.contains('active');
                    endNode.state.inputValues[inputIndex] = isActive ? 1 : 0;
                    console.log(`开关触发器 -> 与门: 传递信号 ${isActive ? 1 : 0}`);
                    
                    // 更新开关和与门的信号指示器
                    updateSignalIndicator(startNode, isActive ? 1 : 0);
                    
                    // 处理与门逻辑后更新其信号指示器
                    processNodeLogic(endNode);
                } else {
                    endNode.state.inputValues[inputIndex] = signalValue;
                    
                    // 更新起始节点和与门的信号指示器
                    updateSignalIndicator(startNode, signalValue);
                    
                    // 处理与门逻辑后更新其信号指示器
                        processNodeLogic(endNode);
                    }
            } else if (endNode.dataset.componentType === '标记储存装置') {
                // 不再根据result.inputIndex确定控制端和输入端
                // 只需传递信号，标记储存装置的process函数会根据信号先后顺序识别控制端和输入端
                if (startNode.dataset.componentType === '开关触发器') {
                    const isActive = startNode.classList.contains('active');
                    // 根据开关状态设置输入值
                    endNode.state.inputValues[inputIndex] = isActive ? 1 : 0;
                    console.log(`开关触发器 -> 标记储存装置: 传递信号 ${isActive ? 1 : 0}`);
                    
                    // 更新开关的信号指示器
                    updateSignalIndicator(startNode, isActive ? 1 : 0);
                } else {
                    // 传递其他组件的信号
                    endNode.state.inputValues[inputIndex] = signalValue;
                    console.log(`${startComponentType} -> 标记储存装置: 传递信号 ${signalValue}`);
                    
                    // 更新起始节点的信号指示器
                    updateSignalIndicator(startNode, signalValue);
                }
            } else {
                // 如果起始节点是开关触发器，需要根据开关状态决定传递的信号值
                if (startNode.dataset.componentType === '开关触发器') {
                    const isActive = startNode.classList.contains('active');
                    endNode.state.inputValues[0] = isActive ? 1 : 0;
                    console.log(`开关触发器 -> ${endComponentType}: 传递信号 ${isActive ? 1 : 0}`);
                    
                    // 更新开关的信号指示器
                    updateSignalIndicator(startNode, isActive ? 1 : 0);
                } else {
                    endNode.state.inputValues[0] = signalValue;
                    
                    // 更新起始节点的信号指示器
                    updateSignalIndicator(startNode, signalValue);
                }
            }
            
            // 处理接收节点的逻辑
            processNodeLogic(endNode);
            
            // 如果起始节点是开关且处于激活状态，确保信号传播
            if (startComponentType === '开关触发器') {
                if (startNode.classList.contains('active')) {
                    console.log(`开关触发器处于打开状态，传播信号1`);
                    propagateSignal(startNode, new Set());
        } else {
                    console.log(`开关触发器处于关闭状态，不传播信号`);
                }
            } else {
                // 其他类型的节点，正常传播信号
                propagateSignal(startNode, new Set());
            }
        }
        
        // 连接成功后记录电路状态
        console.log(`成功创建连接: [${startNode.dataset.componentType}] -> [${endNode.dataset.componentType}]`);
        logCircuitState();
        
        // 自动退出连线模式
        branchMode = false;
        connectingStart = null;
        gridContainer.style.cursor = 'default';
        document.body.classList.remove('connection-mode');
        setCtrlIconActive(false);
        document.querySelectorAll('.connecting-start').forEach(node => {
            node.classList.remove('connecting-start');
        });
        document.querySelectorAll('.selected-input, .selected-output').forEach(node => {
            node.classList.remove('selected-input', 'selected-output');
        });
        
        return connection;
    }

    // Toast弹窗函数
    function showToast(message) {
        let toast = document.getElementById('custom-toast');
        if (!toast) {
            toast = document.createElement('div');
            toast.id = 'custom-toast';
            toast.style.position = 'fixed';
            toast.style.left = '50%'; // 水平居中
            toast.style.top = '15%'; // 靠近屏幕上方
            toast.style.transform = 'translateX(-50%)'; // 确保水平居中
            toast.style.zIndex = 9999;
            toast.style.background = 'rgba(40, 60, 80, 0.95)';
            toast.style.color = '#fff';
            toast.style.padding = '16px 32px';
            toast.style.borderRadius = '12px';
            toast.style.boxShadow = '0 4px 24px rgba(0,0,0,0.18)';
            toast.style.fontSize = '18px';
            toast.style.opacity = '0';
            toast.style.transition = 'opacity 0.3s';
            document.body.appendChild(toast);
        }
        toast.textContent = message;
        toast.style.opacity = '1';
        clearTimeout(toast._timer);
        toast._timer = setTimeout(() => {
            toast.style.opacity = '0';
        }, 1800);
    }

    // 创建一个容器来横向排列所有控制按钮
    function createControlPanel() {
        let panel = document.getElementById('control-panel');
        if (!panel) {
            panel = document.createElement('div');
            panel.id = 'control-panel';
            panel.style.position = 'fixed';
            panel.style.left = '20px';
            panel.style.top = '20px';
            panel.style.display = 'flex';
            panel.style.flexDirection = 'row';
            panel.style.gap = '15px'; // 增加间距
            panel.style.zIndex = '9999';
            // 使用与左侧图标侧边栏完全相同的样式
            panel.style.backgroundColor = 'rgba(35,41,70,0.92)';
            panel.style.borderRadius = '18px';
            panel.style.boxShadow = '0 4px 24px 0 rgba(30,40,80,0.18)';
            panel.style.padding = '15px';
            panel.style.border = '1.5px solid #2a2f4a';
            document.body.appendChild(panel);
        }
        return panel;
    }

    // 添加连接模式按钮
    function addCtrlIcon() {
        const panel = createControlPanel();
        let ctrlButton = document.getElementById('ctrl-connection-icon');
        if (!ctrlButton) {
            // 直接使用图片作为按钮，使用正确的文件名
            ctrlButton = document.createElement('img');
            ctrlButton.id = 'ctrl-connection-icon';
            ctrlButton.src = 'PNG/连接.png'; // 使用正确文件名
            ctrlButton.alt = '连接模式';
            ctrlButton.style.cursor = 'pointer';
            ctrlButton.style.width = 'auto'; // 使用图片原始尺寸
            ctrlButton.style.height = '70px'; // 增大高度
            // 添加鼠标悬停放大效果
            ctrlButton.style.transition = 'transform 0.2s ease, box-shadow 0.2s';
            ctrlButton.style.borderRadius = '10px';
            ctrlButton.style.background = 'rgba(60,70,110,0.12)';
            ctrlButton.style.boxShadow = '0 2px 8px 0 rgba(127,140,255,0.10)';
            
            ctrlButton.onmouseover = function() {
                this.style.transform = 'scale(1.15)';
                this.style.background = 'rgba(127,140,255,0.10)';
            };
            ctrlButton.onmouseout = function() {
                this.style.transform = 'scale(1)';
                this.style.background = 'rgba(60,70,110,0.12)';
            };
            
            // 添加图片加载错误处理
            ctrlButton.onerror = function() {
                console.error('图片加载失败:', this.src);
                // 如果失败，显示一个文本替代
                const text = document.createElement('div');
                text.textContent = '连接';
                text.style.color = 'white';
                text.style.padding = '10px 15px'; // 增大文本替代尺寸
                text.style.fontSize = '18px'; // 增大字体
                text.style.backgroundColor = 'rgba(200, 0, 0, 0.8)';
                text.style.borderRadius = '4px';
                panel.replaceChild(text, this);
            };
            
            panel.appendChild(ctrlButton);
        }
        return ctrlButton;
    }

    // Ctrl键按下/松开时高亮图标
    function setCtrlIconActive(active) {
        const icon = document.getElementById('ctrl-connection-icon');
        if (!icon) return;
        
        if (active) {
            icon.style.boxShadow = '0 0 0 4px var(--secondary-color)';
            icon.style.background = 'rgba(61,218,215,0.10)';
            icon.style.transform = 'scale(1.15)';
        } else {
            icon.style.boxShadow = '0 2px 8px 0 rgba(127,140,255,0.10)';
            icon.style.background = 'rgba(60,70,110,0.12)';
            icon.style.transform = 'scale(1)';
        }
    }

    // 添加清除按钮
    function addClearButton() {
        const panel = createControlPanel();
        let clearButton = document.getElementById('clear-circuit-icon');
        if (!clearButton) {
            // 直接使用图片作为按钮，使用正确的文件名
            clearButton = document.createElement('img');
            clearButton.id = 'clear-circuit-icon';
            clearButton.src = 'PNG/删除.png'; // 修改为删除.png
            clearButton.alt = '删除所有';
            clearButton.style.cursor = 'pointer';
            clearButton.style.width = 'auto'; // 使用图片原始尺寸
            clearButton.style.height = '70px'; // 增大高度
            // 添加鼠标悬停放大效果
            clearButton.style.transition = 'transform 0.2s ease, box-shadow 0.2s';
            clearButton.style.borderRadius = '10px';
            clearButton.style.background = 'rgba(60,70,110,0.12)';
            clearButton.style.boxShadow = '0 2px 8px 0 rgba(127,140,255,0.10)';
            
            clearButton.onmouseover = function() {
                this.style.transform = 'scale(1.15)';
                this.style.background = 'rgba(127,140,255,0.10)';
            };
            clearButton.onmouseout = function() {
                this.style.transform = 'scale(1)';
                this.style.background = 'rgba(60,70,110,0.12)';
            };
            
            // 添加图片加载错误处理
            clearButton.onerror = function() {
                console.error('图片加载失败:', this.src);
                // 如果失败，显示一个文本替代
                const text = document.createElement('div');
                text.textContent = '删除';
                text.style.color = 'white';
                text.style.padding = '10px 15px'; // 增大文本替代尺寸
                text.style.fontSize = '18px'; // 增大字体
                text.style.backgroundColor = 'rgba(200, 0, 0, 0.8)';
                text.style.borderRadius = '4px';
                panel.replaceChild(text, this);
            };
            
            // 添加点击事件
            clearButton.addEventListener('click', function() {
                // 清除节点
                nodes.forEach(node => node.remove());
                nodes = [];
                
                // 清除连接线
                connections.forEach(conn => conn.element.remove());
                connections = [];
                
                // 重置状态
                nodeMode = false;
            branchMode = false;
                
                if (connectingStart) {
                    connectingStart.classList.remove('connecting-start');
            connectingStart = null;
                }
                
                addNodeBtn.classList.remove('active');
                addBranchBtn.classList.remove('active');
                
                // 重置组件ID计数器
                Object.keys(componentCounters).forEach(key => {
                    componentCounters[key] = 0;
                });
                
                // 显示成功提示
                showToast('已删除所有电路元素');
                console.log('删除所有元素');
            });
            
            panel.appendChild(clearButton);
        }
        return clearButton;
    }
    
    // 添加重置连线按钮
    function addResetConnectionsButton() {
        const panel = createControlPanel();
        let resetButton = document.getElementById('reset-connections-icon');
        if (!resetButton) {
            // 直接使用图片作为按钮，使用正确的文件名
            resetButton = document.createElement('img');
            resetButton.id = 'reset-connections-icon';
            resetButton.src = 'PNG/清除.png'; // 修改为清除.png
            resetButton.alt = '清除连线';
            resetButton.style.cursor = 'pointer';
            resetButton.style.width = 'auto'; // 使用图片原始尺寸
            resetButton.style.height = '70px'; // 增大高度
            // 添加鼠标悬停放大效果
            resetButton.style.transition = 'transform 0.2s ease, box-shadow 0.2s';
            resetButton.style.borderRadius = '10px';
            resetButton.style.background = 'rgba(60,70,110,0.12)';
            resetButton.style.boxShadow = '0 2px 8px 0 rgba(127,140,255,0.10)';
            
            resetButton.onmouseover = function() {
                this.style.transform = 'scale(1.15)';
                this.style.background = 'rgba(127,140,255,0.10)';
            };
            resetButton.onmouseout = function() {
                this.style.transform = 'scale(1)';
                this.style.background = 'rgba(60,70,110,0.12)';
            };
            
            // 添加图片加载错误处理
            resetButton.onerror = function() {
                console.error('图片加载失败:', this.src);
                // 如果失败，显示一个文本替代
                const text = document.createElement('div');
                text.textContent = '清除';
                text.style.color = 'white';
                text.style.padding = '10px 15px'; // 增大文本替代尺寸
                text.style.fontSize = '18px'; // 增大字体
                text.style.backgroundColor = 'rgba(0, 100, 200, 0.8)';
                text.style.borderRadius = '4px';
                panel.replaceChild(text, this);
            };
            
            // 添加点击事件
            resetButton.addEventListener('click', function() {
                // 清除连接线
                connections.forEach(conn => {
                    if (conn.element) {
                        conn.element.remove();
                    }
                });
                connections = [];
                
                // 重置节点输入状态
                nodes.forEach(node => {
                    if (node.state) {
                        // 根据组件类型适当重置
                        if (node.dataset.componentType) {
                            const logic = componentLogic[node.dataset.componentType];
                            if (logic) {
                                const inputs = logic.inputs;
                                // 对于开关，保持输入为undefined，保持当前状态
                                if (node.dataset.componentType === '开关触发器') {
                                    node.state.inputValues = new Array(inputs === Infinity ? 2 : inputs).fill(undefined);
                                    // 输出值保持当前状态（开或关）
                                } else {
                                    // 对于其他组件，重置为0
                                    node.state.inputValues = new Array(inputs === Infinity ? 2 : inputs).fill(0);
                                    node.state.outputValues = new Array(logic.outputs === Infinity ? 2 : logic.outputs).fill(0);
                                    
                                    // 更新组件的视觉状态
                                    node.classList.remove('active');
                                    
                                    // 更新信号指示器
                                    if (node.signalIndicator) {
                                        node.signalIndicator.textContent = '0';
                                        node.signalIndicator.style.backgroundColor = 'rgba(0, 0, 0, 0.6)';
                                        node.signalIndicator.style.boxShadow = 'none';
                                    }
                                    
                                    // 如果是灯，更新图片
                                    if (node.dataset.componentType === '灯') {
                                        const imgEl = node.querySelector('.node-icon-img');
                                        if (imgEl) {
                                            imgEl.src = 'PNG/灯.png';
                                        }
                                    }
                                }
                            }
                        }
                    }
                });
                
                // 重置连接状态
                if (connectingStart) {
                    connectingStart.classList.remove('connecting-start');
                    connectingStart = null;
                }
                
                branchMode = false;
            gridContainer.style.cursor = 'default';
            document.body.classList.remove('connection-mode');
            setCtrlIconActive(false);
                
            document.querySelectorAll('.selected-input, .selected-output').forEach(node => {
                node.classList.remove('selected-input', 'selected-output');
            });
                
                // 显示成功提示
                showToast('已清除所有连线');
                console.log('清除所有连线，保留节点');
                
                // 记录电路状态
                logCircuitState();
            });
            
            panel.appendChild(resetButton);
        }
        return resetButton;
    }
    
    // 添加重置状态按钮
    function addResetStateButton() {
        const panel = createControlPanel();
        let resetStateButton = document.getElementById('reset-state-icon');
        if (!resetStateButton) {
            // 直接使用图片作为按钮
            resetStateButton = document.createElement('img');
            resetStateButton.id = 'reset-state-icon';
            resetStateButton.src = 'PNG/重置.png';
            resetStateButton.alt = '重置状态';
            resetStateButton.style.cursor = 'pointer';
            resetStateButton.style.width = 'auto';
            resetStateButton.style.height = '70px';
            resetStateButton.style.transition = 'transform 0.2s ease, box-shadow 0.2s';
            resetStateButton.style.borderRadius = '10px';
            resetStateButton.style.background = 'rgba(60,70,110,0.12)';
            resetStateButton.style.boxShadow = '0 2px 8px 0 rgba(127,140,255,0.10)';
            
            resetStateButton.onmouseover = function() {
                this.style.transform = 'scale(1.15)';
                this.style.background = 'rgba(127,140,255,0.10)';
            };
            resetStateButton.onmouseout = function() {
                this.style.transform = 'scale(1)';
                this.style.background = 'rgba(60,70,110,0.12)';
            };
            
            // 添加图片加载错误处理
            resetStateButton.onerror = function() {
                console.error('图片加载失败:', this.src);
                const text = document.createElement('div');
                text.textContent = '重置';
                text.style.color = 'white';
                text.style.padding = '10px 15px';
                text.style.fontSize = '18px';
                text.style.backgroundColor = 'rgba(0, 150, 136, 0.8)';
                text.style.borderRadius = '4px';
                panel.replaceChild(text, this);
            };
            
            // 添加点击事件
            resetStateButton.addEventListener('click', function() {
                let resetCount = 0;
                
                // 重置所有连接线路的状态
                nodes.forEach(node => {
                    if (node.state) {
                        // 保持节点和连接，只重置状态
                        // 对于开关触发器，保持当前状态不变
                        if (node.dataset.componentType !== '开关触发器') {
                            // 将输出值重置为0
                            if (node.state.outputValues) {
                                node.state.outputValues.fill(0);
                            }
                            
                            // 重置活动状态
                            node.classList.remove('active');
                            
                            // 更新信号指示器
                            if (node.signalIndicator) {
                                node.signalIndicator.textContent = '0';
                                node.signalIndicator.style.backgroundColor = 'rgba(0, 0, 0, 0.6)';
                                node.signalIndicator.style.boxShadow = 'none';
                            }
                            
                            // 如果是灯，更新图片
                            if (node.dataset.componentType === '灯') {
                                const imgEl = node.querySelector('.node-icon-img');
                                if (imgEl) {
                                    imgEl.src = 'PNG/灯.png';
                                }
                            }
                            
                            resetCount++;
                        }
                    }
                });
                
                // 重新传播所有开关的状态以恢复电路功能
                nodes.forEach(node => {
                    if (node.dataset.componentType === '开关触发器' && node.classList.contains('active')) {
                        // 重新传播开关的状态
                        propagateSignal(node, new Set());
                    }
                });
                
                // 显示成功提示
                showToast(`已重置${resetCount}个组件的状态`);
                console.log(`重置了${resetCount}个组件的状态，保留了开关状态和连接`);
                
                // 记录电路状态
                logCircuitState();
            });
            
            panel.appendChild(resetStateButton);
        }
        return resetStateButton;
    }
    
    // 输出图片文件信息用于调试
    console.log('尝试加载PNG文件夹中的图片:', 'PNG/连接.png', 'PNG/删除.png', 'PNG/清除.png', 'PNG/重置.png');
    
    // 初始化按钮
    addCtrlIcon();
    setTimeout(addClearButton, 100);
    setTimeout(addResetConnectionsButton, 100);
    setTimeout(addResetStateButton, 100);

    // 添加连接线点击事件，实现取消连线功能
    function setupConnectionRemoval() {
        // 为所有连接线添加点击事件
        document.addEventListener('click', function(e) {
            // 检查是否点击了连接线
            if (e.target.classList.contains('branch') || 
                e.target.classList.contains('glow-branch') || 
                e.target.classList.contains('branch-path')) {
                
                // 找到对应的连接对象
                const clickedElement = e.target;
                const connectionIndex = connections.findIndex(conn => conn.element === clickedElement);
                
                if (connectionIndex !== -1) {
                    // 找到了连接对象
                    const connection = connections[connectionIndex];
                    
                    // 从DOM中移除连接线
                    connection.element.remove();
                    
                    // 从连接数组中移除
                    connections.splice(connectionIndex, 1);
                    
                    // 显示提示
                    showToast('连接已删除');
                    
                    console.log('删除连接:', connectionIndex);
                }
            }
        });
    }
    
    // 初始化连接删除功能
    setupConnectionRemoval();

    // 修改node双击事件监听，提高灵敏度
    function setupNodeEvents() {
        // 为所有节点添加双击事件，提高灵敏度
        const handleNodeDoubleClick = (node) => {
            if(node.dataset.componentType === '开关触发器') {
                // 不再处理开关触发器的双击事件，改为使用右键菜单
                console.log('请右键点击开关触发器以打开控制菜单');
                showToast('请右键点击开关切换状态');
                return true;
            } else if(node.dataset.componentType === '标记储存装置') {
                resetStorage(node);
                return true;
            }
            return false;
        };
        
        // 使用单击加时间戳模拟双击，提高响应速度
        document.addEventListener('click', function(e) {
            const node = e.target.closest('.node');
            if (!node) return;
            
            // 点击灯组件直接返回，不做处理
            if (node.dataset.componentType === '灯') return;
            
            const now = Date.now();
            if (!node.lastClickTime) {
                node.lastClickTime = now;
                return;
            }
            
            // 如果两次点击间隔小于300ms，认为是双击
            if (now - node.lastClickTime < 300) {
                handleNodeDoubleClick(node);
                e.stopPropagation(); // 阻止事件冒泡
                node.lastClickTime = 0; // 重置点击时间，避免连续触发
            } else {
                node.lastClickTime = now;
            }
        });
        
        // 添加右键菜单事件处理，用于设置延时触发器的延时时间
        document.addEventListener('contextmenu', function(e) {
            const node = e.target.closest('.node');
            if (!node) return;
            
            // 阻止默认右键菜单
            e.preventDefault();
            
            // 对延时触发器节点处理右键事件
            if (node.dataset.componentType === '延时触发器') {
                // 如果之前有其他输入框，先移除
                const existingDialog = document.getElementById('delay-time-dialog');
                if (existingDialog) {
                    existingDialog.remove();
                }
                
                // 显示延时设置输入框
                showDelayTimeInput(node, e.clientX, e.clientY);
            }
            // 对开关触发器节点处理右键事件
            else if (node.dataset.componentType === '开关触发器') {
                // 移除可能存在的开关菜单
                const existingMenu = document.getElementById('switch-menu');
                if (existingMenu) {
                    existingMenu.remove();
                }
                
                // 显示开关菜单
                showSwitchMenu(node, e.clientX, e.clientY);
            }
        });
    }

    // 初始化节点事件处理
    setupNodeEvents();

    // 添加一个新函数用于更新信号指示器
    function updateSignalIndicator(node, value) {
        if (!node || !node.signalIndicator) return;
        
        // 更新信号指示器文本
        node.signalIndicator.textContent = value ? '1' : '0';
        
        // 根据信号值更新指示器样式
        if (value) {
            node.signalIndicator.style.backgroundColor = 'rgba(0, 128, 0, 0.7)'; // 绿色背景表示1
            node.signalIndicator.style.boxShadow = '0 0 5px rgba(0, 255, 0, 0.5)'; // 发光效果
        } else {
            node.signalIndicator.style.backgroundColor = 'rgba(0, 0, 0, 0.6)'; // 黑色背景表示0
            node.signalIndicator.style.boxShadow = 'none';
        }
    }

    // 在关键事件处记录电路状态
    document.addEventListener('node-move', function(e) {
        console.log(`节点移动: ${e.detail.node.dataset.componentType}`);
        logCircuitState();
    });

    // 在脚本最后添加按钮，触发手动记录电路状态
    function addDebugButton() {
        const debugBtn = document.createElement('button');
        debugBtn.textContent = '调试电路';
        debugBtn.style.position = 'fixed';
        debugBtn.style.bottom = '20px';
        debugBtn.style.right = '20px';
        debugBtn.style.padding = '8px 12px';
        debugBtn.style.backgroundColor = '#6200ea';
        debugBtn.style.color = 'white';
        debugBtn.style.border = 'none';
        debugBtn.style.borderRadius = '4px';
        debugBtn.style.cursor = 'pointer';
        debugBtn.style.zIndex = '1000';
        
        debugBtn.onclick = function() {
            console.log('===== 手动触发电路调试 =====');
            logCircuitState();
            
            // 检查潜在问题
            const andGates = nodes.filter(node => node.dataset.componentType === '与门（&）');
            andGates.forEach((gate, index) => {
                const inputs = gate.state ? gate.state.inputValues : [];
                const outputs = gate.state ? gate.state.outputValues : [];
                console.log(`检查与门${index}: 输入=[${inputs.join(',')}], 输出=${outputs[0]}`);
                
                // 判断与门逻辑是否正确
                const validInputs = inputs.filter(v => v !== undefined);
                const expectedOutput = validInputs.length > 0 && validInputs.every(v => v === 1) ? 1 : 0;
                
                if (outputs[0] !== expectedOutput) {
                    console.log(`警告: 与门${index}输出值不正确! 应为${expectedOutput}, 实际为${outputs[0]}`);
                } else {
                    console.log(`与门${index}输出正确`);
                }
            });
        };
        
        document.body.appendChild(debugBtn);
    }

    // 添加调试按钮
    setTimeout(addDebugButton, 1000);

    // 创建延时时间输入对话框
    function showDelayTimeInput(node, x, y) {
        // 创建对话框容器
        const dialog = document.createElement('div');
        dialog.id = 'delay-time-dialog';
        dialog.style.position = 'fixed';
        dialog.style.left = `${x}px`;
        dialog.style.top = `${y}px`;
        dialog.style.padding = '10px';
        dialog.style.backgroundColor = 'rgba(30, 30, 30, 0.9)';
        dialog.style.border = '1px solid #555';
        dialog.style.borderRadius = '5px';
        dialog.style.boxShadow = '0 0 10px rgba(0, 0, 0, 0.5)';
        dialog.style.zIndex = '1001';
        dialog.style.display = 'flex';
        dialog.style.flexDirection = 'column';
        dialog.style.gap = '8px';
        
        // 创建标题
        const title = document.createElement('div');
        title.textContent = '设置延时时间（秒）';
        title.style.color = 'white';
        title.style.fontWeight = 'bold';
        title.style.marginBottom = '5px';
        
        // 当前设置时间文本显示
        const currentTime = document.createElement('div');
        currentTime.textContent = `当前设置: ${node.delayTime || 1} 秒`;
        currentTime.style.color = '#aaa';
        currentTime.style.fontSize = '12px';
        currentTime.style.marginBottom = '5px';
        
        // 创建输入框
        const input = document.createElement('input');
        input.type = 'number';
        input.min = '0.1';
        input.step = '0.1';
        input.value = node.delayTime || 1;
        input.style.padding = '5px';
        input.style.width = '100%';
        input.style.boxSizing = 'border-box';
        input.style.backgroundColor = '#333';
        input.style.color = 'white';
        input.style.border = '1px solid #555';
        input.style.borderRadius = '3px';
        
        // 创建按钮容器
        const buttons = document.createElement('div');
        buttons.style.display = 'flex';
        buttons.style.justifyContent = 'space-between';
        buttons.style.marginTop = '5px';
        
        // 创建确认按钮
        const confirmBtn = document.createElement('button');
        confirmBtn.textContent = '确认';
        confirmBtn.style.padding = '5px 10px';
        confirmBtn.style.backgroundColor = '#4c8bf5';
        confirmBtn.style.color = 'white';
        confirmBtn.style.border = 'none';
        confirmBtn.style.borderRadius = '3px';
        confirmBtn.style.cursor = 'pointer';
        confirmBtn.style.marginRight = '5px';
        confirmBtn.onclick = function() {
            // 获取输入值，并确保它是有效的正数
            const value = parseFloat(input.value);
            if (value > 0) {
                // 保存延时时间到节点状态
                node.delayTime = value;
                showToast(`延时触发器设置为 ${value} 秒`);
                console.log(`延时触发器延时时间设置为 ${value} 秒`);
            } else {
                showToast('延时时间必须大于0');
            }
            dialog.remove();
        };
        
        // 创建取消按钮
        const cancelBtn = document.createElement('button');
        cancelBtn.textContent = '取消';
        cancelBtn.style.padding = '5px 10px';
        cancelBtn.style.backgroundColor = '#555';
        cancelBtn.style.color = 'white';
        cancelBtn.style.border = 'none';
        cancelBtn.style.borderRadius = '3px';
        cancelBtn.style.cursor = 'pointer';
        cancelBtn.onclick = function() {
            dialog.remove();
        };
        
        // 组装按钮
        buttons.appendChild(confirmBtn);
        buttons.appendChild(cancelBtn);
        
        // 组装对话框
        dialog.appendChild(title);
        dialog.appendChild(currentTime);
        dialog.appendChild(input);
        dialog.appendChild(buttons);
        
        // 添加到文档
        document.body.appendChild(dialog);
        
        // 设置焦点到输入框
        input.focus();
        input.select();
        
        // 点击其他地方关闭对话框
        function closeOnOutsideClick(e) {
            if (!dialog.contains(e.target)) {
                dialog.remove();
                document.removeEventListener('mousedown', closeOnOutsideClick);
            }
        }
        
        // 延迟添加事件监听，避免立即触发
        setTimeout(() => {
            document.addEventListener('mousedown', closeOnOutsideClick);
        }, 100);
    }

    function getPortType(node) {
        if (!node || !node.dataset || !node.dataset.componentType) return 'unknown';
        
        const componentType = node.dataset.componentType;
        
        // 只有输出的组件
        if (componentType === '非门（NOT）' || 
            componentType === '分支（BR）' || 
            componentType === '与门（&）' || 
            componentType === 'XOR信号器' || 
            componentType === '或门（OR）' ||
            componentType === '开关触发器') return 'output';
        
        // 只有输入的组件
        if (componentType === '灯') return 'input';
        
        // 既有输入又有输出的组件
        if (componentType === '延时触发器' || 
            componentType === '标记储存装置') {
            return 'both';
        }
        
        return 'unknown';
    }

    // 创建开关菜单函数
    function showSwitchMenu(node, x, y) {
        // 创建菜单容器
        const menu = document.createElement('div');
        menu.id = 'switch-menu';
        menu.style.position = 'fixed';
        menu.style.left = `${x}px`;
        menu.style.top = `${y}px`;
        menu.style.padding = '5px';
        menu.style.backgroundColor = 'rgba(30, 30, 30, 0.95)';
        menu.style.border = '1px solid #555';
        menu.style.borderRadius = '4px';
        menu.style.boxShadow = '0 0 10px rgba(0, 0, 0, 0.5)';
        menu.style.zIndex = '1001';
        menu.style.display = 'flex';
        menu.style.gap = '5px';
        menu.style.animation = 'fadeIn 0.2s ease-out';
        
        // 添加动画样式
        const style = document.createElement('style');
        style.textContent = `
            @keyframes fadeIn {
                from { opacity: 0; transform: translateY(-5px); }
                to { opacity: 1; transform: translateY(0); }
            }
            
            .switch-btn:hover:not([disabled]) {
                transform: translateY(-1px);
                box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
            }
            
            .switch-btn {
                transition: all 0.2s ease;
            }
        `;
        document.head.appendChild(style);
        
        const isActive = node.classList.contains('active');
        
        // 创建开启按钮
        const onBtn = document.createElement('button');
        onBtn.textContent = '开启';
        onBtn.className = 'switch-btn';
        onBtn.style.padding = '5px 10px';
        onBtn.style.backgroundColor = '#4caf50';
        onBtn.style.color = 'white';
        onBtn.style.border = 'none';
        onBtn.style.borderRadius = '3px';
        onBtn.style.cursor = isActive ? 'default' : 'pointer';
        onBtn.style.fontSize = '12px';
        onBtn.style.fontWeight = 'bold';
        
        // 根据当前状态设置禁用状态
        if (isActive) {
            onBtn.style.opacity = '0.6';
            onBtn.disabled = true;
        }
        
        onBtn.onclick = function() {
            if (isActive) return; // 已经是开启状态，不做处理
            
            // 检查是否有输入信号为0
            const hasInputConnections = connections.some(conn => conn.endNode === node);
            const hasZeroInput = hasInputConnections ? 
                node.state.inputValues.some(v => v === 0) : false;
            
            if (hasZeroInput) {
                showToast('无法激活开关：输入信号为0');
                console.log(`开关激活失败：输入信号为0`);
                menu.remove();
                return;
            }
            
            // 添加点击效果
            onBtn.style.transform = 'scale(0.95)';
            setTimeout(() => {
                // 打开开关
                node.classList.add('active');
                node.state.outputValues[0] = 1;
                console.log(`开关从关闭状态切换为打开状态，输出: 1`);
                updateSignalIndicator(node, 1);
                
                // 传播信号变化
                propagateSignal(node, new Set());
                logCircuitState();
                
                menu.remove();
                showToast('开关已开启');
            }, 100);
        };
        
        // 创建关闭按钮
        const offBtn = document.createElement('button');
        offBtn.textContent = '关闭';
        offBtn.className = 'switch-btn';
        offBtn.style.padding = '5px 10px';
        offBtn.style.backgroundColor = '#f44336';
        offBtn.style.color = 'white';
        offBtn.style.border = 'none';
        offBtn.style.borderRadius = '3px';
        offBtn.style.cursor = !isActive ? 'default' : 'pointer';
        offBtn.style.fontSize = '12px';
        offBtn.style.fontWeight = 'bold';
        
        // 根据当前状态设置禁用状态
        if (!isActive) {
            offBtn.style.opacity = '0.6';
            offBtn.disabled = true;
        }
        
        offBtn.onclick = function() {
            if (!isActive) return; // 已经是关闭状态，不做处理
            
            // 添加点击效果
            offBtn.style.transform = 'scale(0.95)';
            setTimeout(() => {
                // 关闭开关
                node.classList.remove('active');
                node.state.outputValues[0] = 0;
                console.log(`开关从打开状态切换为关闭状态，输出: 0`);
                updateSignalIndicator(node, 0);
                
                // 传播信号变化
                propagateSignal(node, new Set());
                logCircuitState();
                
                menu.remove();
                showToast('开关已关闭');
            }, 100);
        };
        
        // 组装按钮
        menu.appendChild(onBtn);
        menu.appendChild(offBtn);
        
        // 添加到文档
        document.body.appendChild(menu);
        
        // 点击其他地方关闭菜单
        function closeOnOutsideClick(e) {
            if (!menu.contains(e.target)) {
                menu.remove();
                document.removeEventListener('mousedown', closeOnOutsideClick);
            }
        }
        
        // 延迟添加事件监听，避免立即触发
        setTimeout(() => {
            document.addEventListener('mousedown', closeOnOutsideClick);
        }, 100);
    }

    // 全局性能相关配置
    const PERFORMANCE_CONFIG = {
        debugLogging: false,         // 设置为false可以减少日志输出
        animationEnabled: true,      // 是否启用动画
        batchUIUpdates: true,        // 是否批量更新UI
        maxConnectionsPerFrame: 10,  // 每帧处理的最大连接数
        useVisitedCache: true        // 是否使用已访问缓存
    };
    
    // 日志函数 - 只在调试模式下输出日志
    function debugLog(...args) {
        if (PERFORMANCE_CONFIG.debugLogging) {
            console.log(...args);
        }
    }

    // 添加键盘事件监听器，检测Shift和Delete键
    document.addEventListener('keydown', function(e) {
        if (e.key === 'Shift' && !isSelectMode) {
            isSelectMode = true;
            console.log('进入选择模式');
            // 添加选择模式的视觉提示
            document.body.style.cursor = 'crosshair';
            showToast('进入选择模式');
        }
        
        // Delete键删除选中节点
        if (e.key === 'Delete' && isSelectMode && selectedNodes.length > 0) {
            deleteSelectedNodes();
        }
    });

    document.addEventListener('keyup', function(e) {
        if (e.key === 'Shift' && isSelectMode) {
            isSelectMode = false;
            console.log('退出选择模式');
            document.body.style.cursor = 'default';
            showToast('退出选择模式');
            
            // 退出选择模式时清除所有选中状态
            unselectNodes();
        }
    });

    // 修改gridContainer的mousedown事件，确保选择模式有更高优先级
    gridContainer.addEventListener('mousedown', function(e) {
        // 在选择模式下，阻止其他mousedown事件处理
        if (isSelectMode) {
            e.stopPropagation();
            e.preventDefault();
            
            console.log('选择模式下处理点击事件');
            
            // 如果点击的是节点
            const node = e.target.closest('.node');
            if (node) {
                console.log('选中节点:', node.dataset.componentType);
                selectNode(node);
            } else {
                // 点击空白区域取消选择
                unselectNodes();
            }
        }
    }, true); // 使用捕获阶段确保优先处理

    // 选择节点函数 - 支持多选
    function selectNode(node) {
        if (!node) return;
        
        // 如果节点已经被选中，不做任何操作
        if (selectedNodes.includes(node)) return;
        
        // 添加到选中节点数组
        selectedNodes.push(node);
        
        // 添加视觉样式
        node.style.boxShadow = '0 0 10px rgba(255, 0, 0, 0.7)';
        node.style.border = '2px solid red';
        node.style.zIndex = '10';
        node.style.position = 'relative';
        node.style.transform = 'scale(1.05)';
        
        console.log(`选中节点 ${node.dataset.componentType}${node.dataset.componentId || ''}`);
        showToast(`选中节点 ${node.dataset.componentType}${node.dataset.componentId || ''}`);
    }

    // 取消选择所有节点
    function unselectNodes() {
        console.log(`取消选择所有节点，共${selectedNodes.length}个`);
        
        // 移除所有节点的选中样式
        selectedNodes.forEach(node => {
            node.style.boxShadow = '';
            node.style.border = '';
            node.style.zIndex = '';
            node.style.position = '';
            node.style.transform = '';
        });
        
        // 清空选中节点数组
        selectedNodes = [];
    }

    // 删除所有选中的节点
    function deleteSelectedNodes() {
        console.log(`删除选中的节点，共${selectedNodes.length}个`);
        
        if (selectedNodes.length === 0) return;
        
        // 复制一份数组，因为删除过程中会修改原数组
        const nodesToDelete = [...selectedNodes];
        
        // 删除所有选中的节点
        nodesToDelete.forEach(node => {
            // 删除与节点相关的所有连接
            connections = connections.filter(conn => {
                if (conn.startNode === node || conn.endNode === node) {
                    conn.element.remove();
                    return false;
                }
                return true;
            });
            
            // 从nodes数组中移除
            const index = nodes.indexOf(node);
            if (index > -1) {
                nodes.splice(index, 1);
            }
            
            // 从DOM中移除
            node.remove();
            
            // 从selectedNodes中移除
            const selectedIndex = selectedNodes.indexOf(node);
            if (selectedIndex > -1) {
                selectedNodes.splice(selectedIndex, 1);
            }
        });
        
        showToast(`已删除${nodesToDelete.length}个节点`);
    }

    // 确保setupNodeSelection函数在任何可能的多选功能之前执行
    setupNodeSelection();
    
    // 初始化端口连接功能
    setupPortConnections();
    
    // 初始化多选功能
    console.log('初始化节点多选功能...');
    
    // 添加键盘事件监听器
    document.addEventListener('keydown', function(e) {
        if (e.key === 'Shift' && !isSelectMode) {
            isSelectMode = true;
            console.log('进入选择模式');
            // 添加选择模式的视觉提示
            document.body.style.cursor = 'crosshair';
            showToast('进入选择模式');
        }
        
        // Delete键删除选中节点
        if (e.key === 'Delete' && isSelectMode && selectedNodes.length > 0) {
            deleteSelectedNodes();
        }
    });

    document.addEventListener('keyup', function(e) {
        if (e.key === 'Shift' && isSelectMode) {
            isSelectMode = false;
            console.log('退出选择模式');
            document.body.style.cursor = 'default';
            showToast('退出选择模式');
            
            // 退出选择模式时清除所有选中状态
            unselectNodes();
        }
    });

    // 修改gridContainer的mousedown事件，确保选择模式有更高优先级
    gridContainer.addEventListener('mousedown', function(e) {
        // 在选择模式下，阻止其他mousedown事件处理
        if (isSelectMode) {
            e.stopPropagation();
            e.preventDefault();
            
            console.log('选择模式下处理点击事件');
            
            // 如果点击的是节点
            const node = e.target.closest('.node');
            if (node) {
                console.log('选中节点:', node.dataset.componentType);
                selectNode(node);
            } else {
                // 点击空白区域取消选择
                unselectNodes();
            }
        }
    }, true); // 使用捕获阶段确保优先处理
}); 